<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    algorithmes de parcours d&#39;un graphe
  
 | Allophysique</title>


<link href="https://fonts.googleapis.com/css?family=Oxygen|Oxygen+Mono:300,400,700" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" rel="stylesheet"> 


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-167114468-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-167114468-1');
</script>





<link rel="stylesheet" href="/book.min.757bde8284addd9205931692e0522a4e50ed085e00c44dff802d2fc8255c68ca.css">


<link rel="icon" href="/favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  

<div class="my-header-container">
<div class="my-site-header">
	<img src="/logo-site-b.svg" width = "150 px"/>
</div>

<div id="myHeader">
	<div class="titre">
	<h2><a href="/">Allophysique</a></h2>
    </div>
</div>
</div>



<script async>
window.onload = function () {
let container = document.getElementsByClassName("book-page");
let logodiv = document.getElementsByClassName("site-menu-before");
let header = document.getElementById("myHeader");
let screen = window.innerWidth;
let site_footer = document.querySelector(".site_footer");

try {
  
  let site_TOC = document.querySelector("#TableOfContents>ul");
  let newP = document.createElement('li');

  newP.textContent='Contenu de la page';
  site_TOC.appendChild(newP,null);
}
catch(err)
{
    console.log(err.message);
}




if (site_footer.parentNode != document.body){
    let father = site_footer.parentNode;
    let clone = site_footer.cloneNode;
    father.removeChild(site_footer);
    document.body.appendChild(clone);
}





if (screen<=850) {

  document.getElementsByClassName("my-site-header")[0].style.display="none";
} else {

	window.addEventListener("scroll", function(e) {
	let spectral=document.getElementById("spectral");
	if (screen>850 ){
		if (window.pageYOffset > 150) {
			header.classList.add("sticky");
    		if (container.lenght>0) {container[0].style.marginTop="65px";};
            logodiv[0].style.height="120px";
    	} else {
    	header.classList.remove("sticky");
    	if (container.lenght>0) {container[0].style.marginTop="0px";};
    	spectral.style.display="none";
        logodiv[0].style.height="220px";
    	}

    } 
    if (screen<=850) {

    	if (window.pageYOffset > 150){
    		spectral.style.display="block";
    	} else {
    		spectral.style.display="none";
    	}
    }
});
}


}





 
let chemin = window.location.pathname;
if (chemin.search('NSI')>-1) {
baniere=document.querySelector("#myHeader");


let linkBox = document.createElement('div');
linkBox.classList.add('linkBox');
let newH = document.createElement('a');
newH.innerHTML='<a href="/docs/NSI_1/NSI_index/index.html">NSI</a>';

newH.classList.add('nsi');

linkBox.appendChild(newH);
baniere.appendChild(linkBox); 
}
</script>

<style>
  #myHeader{
    display:flex;
    flex-direction: row-reverse;
  }
  #myHeader>.titre{
    width:80%;
    min-width:300px;
    text-align: left;

    
  }
  .linkBox{
    margin:10px;
    padding-top:10px;
    background-color: pink;
    
    min-width:50px;

  }
  .isn{
     
    
  }
</style>



</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      
<nav role="navigation">

<div class="site-menu-before" style="height:220px; display:block;" >
<img src="/logo-site.svg" id="spectral" height="50%" style="display:none;">	

</div>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fSNT_2nde\2fpages\2fpages_algo\2fgraphes\2fpage2\2f "] {
      color: #004ed0;
  }
  </style>

<ul>
<li>
<p><a href="/"><strong>Accueil</strong></a></p>
</li>
<li>
<p><a href="/docs/SNT_2nde/SNT_index/"><strong>SNT secondes</strong></a></p>
</li>
<li>
<p><a href="/docs/NSI_1/NSI_index/"><strong>NSI 1ere</strong></a></p>
</li>
<li>
<p><a href="/docs/NSI/NSI_index/"><strong>NSI Term</strong></a></p>
</li>
<li>
<p><a href="/docs/PC_2nde/PC_index/"><strong>Physique Chimie 2nde</strong></a></p>
</li>
<li>
<p><a href="/docs/PC_1ere/PC_index/"><strong>Physique 1ere Spé</strong></a></p>
</li>
<li>
<p><a href="/docs/esf/esf_index/"><strong>ESF</strong></a></p>
</li>
<li>
<p><a href="/docs/python/index_python_D/"><strong>Python debutant</strong></a></p>
</li>
<li>
<p><a href="/docs/python/index_python/"><strong>Python avancé</strong></a></p>
</li>
<li>
<p><a href="/docs/techno/index_microcontroleurs/"><strong>Techno</strong></a></p>
</li>
<li>
<p><a href="/posts/"><strong>Posts</strong></a></p>
</li>
<li>
<p><a href="/docs/contact/simple-contact-form/"><strong>Contact</strong></a></p>
</li>
</ul>





</nav>



  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">

  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    algorithmes de parcours d&#39;un graphe
  
</strong>
</header>

      
<article class="markdown"><h1 id="algorithmes-de-parcours-dun-graphe-en-largeur">algorithmes de parcours d&rsquo;un graphe en largeur</h1>
<ul>
<li>Algorithme : voir définition en bas de page<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></li>
<li>Graphe : voir définitions à la page <a href="../page1/index.html">Graphes</a></li>
</ul>
<h2 id="parcours-dun-graphe-non-pondéré">Parcours d&rsquo;un graphe non pondéré</h2>
<p>Soit G(V,E) un graphe de sommets V = {A,B,C,D,E,F,G,H,I,J} et d&rsquo;arêtes E.</p>
<p>On note la distance entre 2 sommets quelconques u et v dans le graphe G : $$dist_G(u,v)$$</p>
<p>Pour le graphe exemple suivant (Graphe 1), la distance du sommet A au sommet J, vaut au minimum 4 (chemin A, B, E, I, J). Mais cela depend du chemin. Ainsi :
$$dist_G(A,J)=4$$.</p>
<!-- raw HTML omitted -->
<blockquote>
<p>Calculons toutes les distances dans ce graphe : <strong>L&rsquo;algorithme de parcours en largeur (Breath First Search BFS)</strong></p>
</blockquote>
<p><strong>Principe :</strong>
Pour déterminer la longueur de tous les chemins du graphe, il va falloir le parcourir. Lors du parcours, certains sommets seront colorés, pour nous rappeler qu&rsquo;ils ont été parcouru (rouge), ou en cours de parcours (vert).</p>
<p>On aura besoin de conserver une liste L des sommets à explorer.</p>
<p>On commence l&rsquo;exploration en partant d&rsquo;un sommet <em>r</em>. Voici la méthode :</p>
<blockquote>
</blockquote>
<ol>
<li>Colorer en VERT le sommet <code>r</code> pour se rappeler qu&rsquo;il a déjà été partiellement traité.</li>
<li>Parcourir le graphe depuis <code>r</code> jusqu&rsquo;à l&rsquo;un de ses voisins <code>u</code>, non coloré en vert ou rouge. Colorer <code>u</code> en VERT.</li>
<li>Noter la distance du sommet de départ <code>r</code> vers le sommet <code>u</code> en cours d&rsquo;exploration : dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(r,u) = 1 si le sommet voisin <code>u</code> est adjacent.</li>
<li>Ajouter le nom du sommet <code>u</code> à droite dans la liste <code>L</code>: <code>L = [r,u]</code></li>
<li>Si <code>r</code> a d&rsquo;autres sommets adjacents, revenir au point 2 et explorer un autre de ces sommets (points 2, 3, 4).</li>
<li>Si <code>r</code> n&rsquo;a plus de sommet adjacent non visité, colorer <code>r</code> en rouge. Retirer <code>r</code> de la liste (premier sommet, à gauche dans la liste L). <code>L</code> ayant une structure de FILE, on dit que l&rsquo;on <em>défile</em> <code>r</code>.</li>
</ol>
<p>On poursuit ensuite l&rsquo;exploration à partir du nouveau premier sommet <code>v</code> adjacent de <code>u</code>. La distance de r à v est alors : dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(r,v) = dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(r,u) + 1 (point 3).</p>
<p>Lorsque la liste L est vide, l&rsquo;exploration est terminée et toutes les distances entre r et les autres sommets est connue.</p>
<p><strong>Exemple :</strong></p>
<p>A partir du graphe 1 défini plus haut, on démarre l&rsquo;exploration à partir du sommet r = E.</p>
<p>Celui ci est coloré en VERT.</p>
<p>La méthode vue plus haut permet de rapidement établir la liste L = [E,B,F,H,I] à partir des sommets adjacents à E. Les sommets B,F,H,I sont à une distance 1 du sommet E. On a par exemple dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(E,B) = 1. Ces sommets sont colorés en VERT.</p>
<p>Une fois cette première partie de l&rsquo;exploration terminée, on retire E de la liste L, et on colore le sommet en rouge.</p>
<!-- raw HTML omitted -->
<p>On note la distance au sommet <code>E</code> pour chacun des sommets visités, le symbole ∞ pour ceux qui ne l&rsquo;ont pas encore été:</p>
<table>
<thead>
<tr>
<th>exploration depuis le sommet&hellip;</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
<td>∞</td>
<td>1</td>
<td>∞</td>
<td>1</td>
<td>1</td>
<td>∞</td>
</tr>
</tbody>
</table>
<p>On se déplace maintenant sur le sommet B, qui est le premier de la liste.</p>
<p>L&rsquo;exploration de ses sommets adjacents continue, à conditions que ceux-ci soient blancs, sinon, on passe à un autre sommet. Ici, on fait l&rsquo;exploration des sommets A,C,D. Ceux-ci sont colorés en VERT, et ajoutés à la liste L:
$$L = [F,H,I,A,C,D]$$</p>
<p>Les distances de E à chacun de ces nouveaux noeuds sont enregistrées :
dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(E,A) = 2, tout comme dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(E,C) et dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(E,D). Le tableau suivant donne les distances depuis le sommet <code>E</code>:</p>
<table>
<thead>
<tr>
<th>exploration depuis le sommet&hellip;</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>2</td>
<td></td>
<td>2</td>
<td>2</td>
<td></td>
<td>∞</td>
<td></td>
<td></td>
<td>∞</td>
</tr>
</tbody>
</table>
<p>Les distances déjà connues ne sont pas modifiées. On laisse un blanc dans le tableau.</p>
<p>On colore ensuite le sommet B en rouge et on le retire de la liste L.</p>
<!-- raw HTML omitted -->
<p>Ensuite, depuis le sommet F: on explore le graphe jusqu&rsquo;au sommet G, seul sommet adjacent encore blanc.</p>
<p>On a alors dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(E,G) = 2, puis le sommet F est mis en rouge et retiré de la liste:</p>
<p>$$L = [H,I,A,C,D,G]$$</p>
<table>
<thead>
<tr>
<th>exploration depuis le sommet&hellip;</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>F</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td></td>
<td>∞</td>
</tr>
</tbody>
</table>
<p>On poursuivra l&rsquo;exploration par le sommet H, suivant dans la liste. Ce qui permettra de définir le dernier chemin jusqu&rsquo;à J, et noter dist<!-- raw HTML omitted -->G<!-- raw HTML omitted -->(E,J) = 2:</p>
<table>
<thead>
<tr>
<th>exploration depuis le sommet&hellip;</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>F</th>
<th>G</th>
<th>H</th>
<th>I</th>
<th>J</th>
</tr>
</thead>
<tbody>
<tr>
<td>H</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>2</td>
</tr>
</tbody>
</table>
<p>A la fin du traitement, on peut représenter à l&rsquo;aide d&rsquo;un <em>arbre</em> tous les chemins issus de l&rsquo;exploration du graphe :</p>
<!-- raw HTML omitted -->
<p>Pour réaliser cet arbre, il faudra remonter chaque étape du parcours du graphe le parent du sommet visité. Ainsi, il aura faudra se rappeler que le sommet D a pour parent le noeud B (D est marqué dans le tableau dont l&rsquo;entrée est B). Et le sommet B a lui même pour parent le sommet E. Ainsi, en remontant le chemin, on sait que le chemin de E à D passe par B : E =&gt; B =&gt; D.</p>
<h3 id="pour-aller-plus-loin-term-nsi">Pour aller plus loin (term NSI)</h3>
<ul>
<li>
<p>Consulter la page du <em>parcours en largeur</em> sur <a href="https://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_largeur">wikipedia</a></p>
</li>
<li>
<p><a href="../page4/">Algorithme de Dijkstra</a> (plus court chemin dans un graphe pondéré)</p>
</li>
<li>
<p>Application de l&rsquo;algorithme <strong>BFS</strong> au parcours dans un <strong>labyrinthe</strong>:</p>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="parcours-dun-arbre-en-profondeur-dfs">Parcours d&rsquo;un arbre en profondeur (DFS)</h1>
<h2 id="principe">Principe</h2>
<p>Soit un graphe G = (V,E) et r un sommet de G, point de départ de l&rsquo;exploration.
Le parcours en profondeur du graphe va permettre de visiter tous les noeuds du graphe, mais selon un chemin où l&rsquo;on plonge dans la profondeur du graphe. Le prochain sommet visité sera un sommet fils non encore visité.</p>
<p>A chaque étape, c&rsquo;est à dire à chaque arête suivie, il faudra mémoriser le parent du nouveau sommet visité. Cela permettra de revenir en arrière. On utilisera pour cela une structure de PILE. On reviendra en arrière en <em>dépilant</em> le dernier sommet de la liste.</p>
<p>Lorsque le chemin mène à une impasse, (il n&rsquo;y a plus de sommet fils non visité), lorsque l&rsquo;on est sur un bord du graphe, alors on <em>remonte</em> d&rsquo;un niveau, vers un sommet parent, <em>avant de poursuivre</em> l&rsquo;exploration.</p>
<p>En pratique :</p>
<ul>
<li>tous les sommets ont d&rsquo;abord colorés en BLANC.</li>
<li>On colore chaque noeud u visité en VERT.</li>
<li>Lorsque tous les noeuds fils de u sont visités, on colore celui-ci en ROUGE.</li>
</ul>
<p><strong>Illustration :</strong>
Avec le graphe suivant, on démarre l&rsquo;exploration du noeud G :</p>
<!-- raw HTML omitted -->
<p>La première étape est la phase de descente : On peut démarrer l&rsquo;exploration par le sommet voisin A ou B. Les deux sont possibles. Ils sont de couleur BLANCHE.</p>
<p>Supposons que l&rsquo;on commence l&rsquo;exploration par B (on aurait tout aussi bien choisir le A). On colore alors B en VERT.</p>
<p>On poursuit l&rsquo;exploration par les sommets suivants : D,C,A (il y a d&rsquo;autres possibiltés) :</p>
<!-- raw HTML omitted -->
<p>Le sommet A est un bord du graphe : il n&rsquo;y a pas de noeud fils BLANC. On remonte alors d&rsquo;un niveau : jusqu&rsquo;au sommet C. Celui ci ne presente pas davantage de voisin BLANC. A et C sont colorés en ROUGE et on remonte à D.</p>
<p>On peut alors poursuivre l&rsquo;exploration vers E :</p>
<!-- raw HTML omitted -->
<p>Depuis le sommet E, on peut visiter F et I. Choisissons F (mais on pourrait choisir également I) :</p>
<!-- raw HTML omitted -->
<p>On poursuit l&rsquo;exploration jusqu&rsquo;en I. Tous les sommets sont visités, et l&rsquo;exploration est terminée.</p>
<!-- raw HTML omitted -->
<p>Le schéma suivant illustre le parcours réalisé à partir des arêtes empruntées. Il s&rsquo;agit d&rsquo;un arbre couvrant le graphe :</p>
<!-- raw HTML omitted -->
<h2 id="applications">Applications</h2>
<p>Le parcours d&rsquo;un graphe en profondeur s&rsquo;apparente à un algorithme de type <em>retour sur trace</em>, ou <em>backtracking</em>. C&rsquo;est le comportement de joueur que l&rsquo;on a lorsque l&rsquo;on a droit à un nouvelle chance :</p>
<ul>
<li>Dans un jeu d&rsquo;echec, lorsque l&rsquo;on joue contre l&rsquo;ordinateur, une option permet de <em>revenir en arrière</em>. On peut revenir <em>un coup</em> en arrière et prendre une meilleure option. L&rsquo;ordinateur construit un graphe au fur et à mesure du jeu avec les coups joués ainsi que la configuration du jeu, afin de permettre ce backtracking.</li>
<li>Lorsque l&rsquo;on joue à un jeu de labyrinthe : Si on arrive dans une impasse, on adopte là aussi un algorithme de type <em>retour sur trace</em>. On revient jusqu&rsquo;au noeud parent (le croisement précédent) afin d&rsquo;explorer une nouvelle voie. Et si toutes ces voies sont sans issues, on remonte encore d&rsquo;un niveau (le croisement précédent encore celui ci).</li>
</ul>
<h1 id="liens">Liens</h1>
<ul>
<li>Approfondir le sujet: les différents algorithmes de parcours des graphes (Term NSI): <a href="https://pixees.fr/informatiquelycee/n_site/nsi_term_algo_graphe.html">site pixees de David Roche</a></li>
</ul>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>algorithmes : ce sont des méthodes qui, exécutées pas à pas, permettent d&rsquo;obtenir un résultat final à partir de données de départ.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
</article>

      

      <div style="height:100px;"></div>



    </div>

    
  

  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#parcours-dun-graphe-non-pondéré">Parcours d&rsquo;un graphe non pondéré</a>
      <ul>
        <li><a href="#pour-aller-plus-loin-term-nsi">Pour aller plus loin (term NSI)</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#principe">Principe</a></li>
    <li><a href="#applications">Applications</a></li>
  </ul>
</nav>
  </aside>



  </main>
  
  

<div class="site_footer">
<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Licence Creative Commons" style="border-width:0" src="/creative.png" /></a>


<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Sciences numeriques</span> de <a xmlns:cc="http://creativecommons.org/ns#" href="" property="cc:attributionName" rel="cc:attributionURL">numerix.netlify.com</a> est mis à disposition selon les termes de la <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">licence Creative Commons Attribution 4.0 International</a>



</div>
  
</body>

</html>
