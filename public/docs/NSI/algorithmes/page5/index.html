<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>diviser
| Sciences numériques</title><link href="https://fonts.googleapis.com/css?family=Oxygen|Oxygen+Mono:300,400,700" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" rel=stylesheet><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-167114468-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-167114468-1');</script><link rel=stylesheet href=/book.min.1c02dc1d2c0b546a84beb71d8f4336d6f5d7b69564e08bdfc04c2fb0595d786d.css><link rel=icon href=/favicon.png type=image/x-icon><div class=my-header-container><div class=my-site-header><img src=/logo-site-b.svg width="150 px"></div><div id=myHeader><div class=titre><h2><a href=/>Sciences numériques</a></h2></div></div></div><script async>window.onload=function(){let container=document.getElementsByClassName("book-page");let logodiv=document.getElementsByClassName("site-menu-before");let header=document.getElementById("myHeader");let screen=window.innerWidth;let site_footer=document.querySelector(".site_footer");try{let site_TOC=document.querySelector("#TableOfContents>ul");let newP=document.createElement('li');newP.textContent='Contenu de la page';site_TOC.appendChild(newP,null);}
catch(err)
{console.log(err.message);}
if(site_footer.parentNode!=document.body){let father=site_footer.parentNode;let clone=site_footer.cloneNode;father.removeChild(site_footer);document.body.appendChild(clone);}
if(screen<=850){document.getElementsByClassName("my-site-header")[0].style.display="none";}else{window.addEventListener("scroll",function(e){let spectral=document.getElementById("spectral");if(screen>850){if(window.pageYOffset>150){header.classList.add("sticky");if(container.lenght>0){container[0].style.marginTop="65px";};logodiv[0].style.height="120px";}else{header.classList.remove("sticky");if(container.lenght>0){container[0].style.marginTop="0px";};spectral.style.display="none";logodiv[0].style.height="220px";}}
if(screen<=850){if(window.pageYOffset>150){spectral.style.display="block";}else{spectral.style.display="none";}}});}}
let chemin=window.location.pathname;if(chemin.search('NSI')>-1){baniere=document.querySelector("#myHeader");let linkBox=document.createElement('div');linkBox.classList.add('linkBox');let newH=document.createElement('a');newH.innerHTML='<a href="/docs/NSI/NSI_index/index.html">NSI</a>';newH.classList.add('nsi');linkBox.appendChild(newH);baniere.appendChild(linkBox);}</script><style>#myHeader{display:flex;flex-direction:row-reverse}#myHeader>.titre{width:80%;min-width:300px;text-align:left}.linkBox{margin:10px;padding-top:10px;background-color:pink;min-width:50px}.isn{}</style></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav role=navigation><div class=site-menu-before style=height:220px;display:block><img src=/logo-site.svg id=spectral height=50% style=display:none></div><style>nav ul a[href$=\2f docs\2fNSI\2f algorithmes\2fpage5\2f ]{color:#004ed0}</style><ul><li><a href=/><strong>Accueil</strong></a></li><li><a href=/docs/esf/esf_index/><strong>ESF</strong></a></li><li><p><a href=/docs/SNT_2nde/SNT_index/><strong>SNT secondes</strong></a></p></li><li><p><a href=/docs/NSI/NSI_index/><strong>NSI</strong></a></p></li><li><p><a href=/docs/python/index_python/><strong>Python</strong></a></p></li><li><p><a href=/docs/PC_2nde/PC_index/><strong>Physique Chimie 2nde</strong></a></p></li><li><p><a href=/docs/PC_1ere/PC_index/><strong>Physique 1ere Spé</strong></a></p></li><li><p><a href=/posts/><strong>Posts</strong></a></p></li><li><p><a href=/docs/contact/simple-contact-form/><strong>Contact</strong></a></p></li></ul></nav><script>(function(){var menu=document.querySelector('aside.book-menu nav')
addEventListener('beforeunload',function(event){localStorage.setItem('menu.scrollTop',menu.scrollTop)});menu.scrollTop=localStorage.getItem('menu.scrollTop')})()</script></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg alt=Menu></label>
<strong>diviser</strong></header><article class=markdown><p><em>Prérequis :</em></p><ul><li>voir la <a href=../page1>page sur la complexité</a></li><li>et la <a href=/docs/NSI/langages/page2/>page sur la récursivité</a></li></ul><h1 id=diviser-pour-regner>Diviser pour regner</h1><p>C&rsquo;est une technique informatique qui consiste à :</p><ol><li>Diviser : découper un problème initial en sous-problèmes de tailles équivalentes;</li><li>Régner : résoudre les sous-problèmes (récursivement ou directement s&rsquo;ils sont assez petits) ;</li><li>Combiner : calculer une solution au problème initial à partir des solutions des sous-problèmes.</li></ol><p>Cette méthode, lorsqu&rsquo;elle s&rsquo;applique, fournit un algorithme de complexité plus réduite, et donc plus efficace.</p><p><strong>Definition :</strong> Un problème est de type <em>diviser pour regner</em> si sa resolution se ramène à celle de un ou plusieurs problèmes indépendants dont la taille des entrées passe de <strong>n</strong> à <strong>n/2</strong>, ou une fraction de n. Ou bien, si la division en plusieurs problèmes permet de réduire la durée necessaire pour sa resolution.</p><h1 id=exemple-introductif-te-le-phone-en-chai-ne>Exemple introductif : téléphone en chaîne</h1><p>Les 15 joueuses d’une équipe de volleyball ont la liste des joueuses de l’équipe avec leur numéro de téléphone. La capitaine reçoit l’information que le prochain match a été déplacé. Il faut prévenir toutes les autres joueuses.</p><ul><li>Solution 1 : la capitaine se charge d’appeler toutes les autres joueuses. Et si elle passe 5 minutes au téléphone avec chacune d’entre-elles&hellip;<br></li></ul><blockquote><p><strong>Question à propos de la solution 1</strong> <em>: En combien de temps (noté t1) l’ensemble de l’équipe est informé? En déduire la complexité de cette solution en fonction de n (taille de l’équipe)</em></p></blockquote><ul><li>Solution 2 : Une solution plus efficace et plus confortable pour la capitaine est qu’elle divise la liste de joueuses en deux moitiés. Elle appelle alors la première joueuse de chacune des deux listes obtenues. Elle leur donne l’information de report de match et leur demande à leur tour de faire la même chose : diviser en deux la demi-liste à laquelle elles appartiennent, appeler la première joueuse de chacune des parties et ainsi de suite &hellip; jusqu’à ce qu’il n’y ait plus personne à prévenir.<br>Représentons l’arbre des appels pour la liste de 15 joueuses numérotées de 1 à 15.</li></ul><figure><img src=../images/page5_appels.png width=250px alt="arbre binaire des appels"><figcaption>arbre des appels</figcaption></figure><blockquote><p><strong>Question à propos de la solution 2:</strong> <em>Si on suppose qu’un appel téléphonique dure 5 min. En combien de temps (noté t2) l’ensemble de l’équipe est informé ? En déduire la complexité de cette solution en fonction de n (taille de l’équipe)</em></p></blockquote><p><strong>Conclusion:</strong> La solution 2 illustre bien la méthode <em>Diviser pour regner</em> puisqu&rsquo;à chaque nouvel appel telephonique, le nombre de joueuses contactées avec le même message va doubler. La durée necessaire pour la resolution du problème initial (téléphoner à toutes les joueuses) est alors réduite de manière significative.</p><h1 id=exponentiation>Exponentiation</h1><p>L&rsquo;exponentiation consiste à trouver une méthode pour calculer x à la puissance n, SANS utiliser l&rsquo;opérateur <em>puissance</em>. L&rsquo;idée est de se rappocher de l&rsquo;algorithme utilisé par le processeur d&rsquo;un ordinateur, qui n&rsquo;utilise que les 3 opérateurs de base pour effectuer les calculs (+,-,*).</p><h2 id=programme-itératif>Programme itératif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>exp1</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>)</span> <span style=color:#111>:</span> 
  <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>  programme qui donne x^n en sortie
</span><span style=color:#d88200>  n : entier
</span><span style=color:#d88200>  x : reel
</span><span style=color:#d88200>  exp1 : reel
</span><span style=color:#d88200>  &#34;&#34;&#34;</span>
  <span style=color:#111>acc</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#111>):</span>
    <span style=color:#111>acc</span><span style=color:#f92672>*=</span><span style=color:#111>x</span>
  <span style=color:#00a8c8>return</span> <span style=color:#111>acc</span></code></pre></div><div class=preuve><div class=entete>Complexité</div><div class=demo>La boucle for est exécutée n fois. Il y a, à chaque itération, une opération arithmétique qui est réalisée (multiplication par x), et une affectation (le résultat est affecté à <span class=ital>acc</span>).<br>Il y a donc au total :
<strong>2n + 1</strong> opérations.<br>La complexité est O(n).</div></div><h2 id=programme-récursif>Programme récursif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>exp2</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    n : entier
</span><span style=color:#d88200>    x : reel
</span><span style=color:#d88200>    exp2 : reel
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>n</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>else</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>exp2</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>)</span><span style=color:#f92672>*</span><span style=color:#111>x</span></code></pre></div><p>On pourrait montrer que la complexité est aussi O(n).</p><h2 id=exponentiation-rapide-application-de-la-méthode-diviser-pour-regner>Exponentiation rapide : application de la méthode diviser pour regner</h2><p>Comme de nombreux algorithmes utilisant cette méthode, celui-ci fait des appels recursifs. Mais à la différence du précédent, l&rsquo;appel recursif se fait avec un paramètre que l&rsquo;on divise par 2 (le paramètre n). C&rsquo;est ce qui fait que le nombre d&rsquo;appels récursifs est plus réduit.
On retrouve l&rsquo;étape 3 évoquée en introduction (la combinaison des sous problèmes) lorsque l&rsquo;on réalise l&rsquo;opération : <code>return y*y</code> ou bien <code>return x*y*y</code>.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>exp3</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    programme plus efficace que le precedent car
</span><span style=color:#d88200>    le nombre d&#39;operations est log2(n)
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>n</span><span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>else</span> <span style=color:#111>:</span>
        <span style=color:#111>y</span> <span style=color:#f92672>=</span> <span style=color:#111>exp3</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>//</span><span style=color:#ae81ff>2</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>)</span>  <span style=color:#75715e># on prend la valeur inferieure de n/2</span>
        <span style=color:#00a8c8>if</span> <span style=color:#111>n</span><span style=color:#f92672>%</span><span style=color:#ae81ff>2</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span><span style=color:#111>:</span>
            <span style=color:#00a8c8>return</span> <span style=color:#111>y</span><span style=color:#f92672>*</span><span style=color:#111>y</span>
        <span style=color:#00a8c8>else</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>x</span><span style=color:#f92672>*</span><span style=color:#111>y</span><span style=color:#f92672>*</span><span style=color:#111>y</span></code></pre></div><div class=preuve><div class=entete>Complexité</div><div class=demo>Prenons pour exemple n = 8 :<br>Dans la phase de descente:
exp3(8,x) appelle exp3(4,x) appelle exp3(2,x) qui appelle exp3(1,x) puis exp3(0,x).<br>Dans la phase de remontée: Une seule opération est réalisée à chaque appel recursif : y*y<br>C'est comme si l'on <b>dupliquait</b> le résultat de chaque multiplication (voir représentation en arbre plus bas)<ul><li>exp3(0,x) retourne 1</li><li>exp3(1,x) retourne x * 1 * 1</li><li>exp3(2,x) retourne x * x</sup></li><li>exp3(4,x) retourne x<sup>2</sup> * x<sup>2</sup></li><li>exp3(8,x) retourne x<sup>4</sup> * x<sup>4</sup></li></ul>Le nombre d'opérations est le nombre de divisions par 2 qu'il faut faire pour reduire n à 0. Ce nombre est justement egal à : $$log_2(n)$$</div></div><p><br><figure><img src=../images/expo.png alt="exponentiation rapide: représentation en arbre"><figcaption>représentation en arbre</figcaption></figure></p><p>L’exponentiation rapide peut être utilisée pour des “multiplications” plus compliquées, comme la multiplication de matrices, la composition de fonctions,&hellip; Dans ces cas, il ne faut pas oublier de compter le coût de la multiplication dans les calculs, qui n’est pas toujours constant.</p><h1 id=le-tri-fusion>Le Tri Fusion</h1><h2 id=principe>Principe</h2><p>Le tri fusion est un autre <a href=/docs/NSI/algorithmes/page8/>algorithme de tri</a>. Celui-ci présente l&rsquo;avantage d&rsquo;utiliser la méthode <em>Diviser pour Regner</em>.</p><p>Les étapes 1 et 2 de la méthode <em>Diviser pour Regner</em> consistent à diviser la liste en 2 sous-listes, de manière recursive, jusqu&rsquo;à obtenir des listes de 1 élément.</p><p>L&rsquo;étape 3, enfin consiste à <strong>interclasser</strong> les sous-listes deux à deux.</p><p>Le tri fusion est réalisé par la fonction <code>fusion</code> suivante:</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fusion</span><span style=color:#111>(</span><span style=color:#111>L</span><span style=color:#111>):</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>len</span><span style=color:#111>(</span><span style=color:#111>L</span><span style=color:#111>)</span> <span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>1</span><span style=color:#111>:</span>
        <span style=color:#00a8c8>return</span> <span style=color:#111>L</span>
    <span style=color:#111>m</span> <span style=color:#f92672>=</span> <span style=color:#111>len</span><span style=color:#111>(</span><span style=color:#111>L</span><span style=color:#111>)</span><span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>
    <span style=color:#111>gauche</span> <span style=color:#f92672>=</span> <span style=color:#111>fusion</span><span style=color:#111>(</span><span style=color:#111>L</span><span style=color:#111>[:</span><span style=color:#111>m</span><span style=color:#111>])</span>
    <span style=color:#111>droite</span> <span style=color:#f92672>=</span> <span style=color:#111>fusion</span><span style=color:#111>(</span><span style=color:#111>L</span><span style=color:#111>[</span><span style=color:#111>m</span><span style=color:#111>:])</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>interclassement</span><span style=color:#111>(</span><span style=color:#111>gauche</span><span style=color:#111>,</span><span style=color:#111>droite</span><span style=color:#111>)</span></code></pre></div><p>La fonction <code>fusion</code> ressemble à celle du <em>parcours récursif</em> d&rsquo;un arbre dans lequel, pour un noeud contenant une liste L:</p><ul><li>le fils gauche est la sous-liste de gauche (la première moitié de L)</li><li>le fils droit est la sous-liste de droite (la deuxième moitié de L)</li></ul><p>Le traitement se faisant APRES les 2 appels recursifs (gauche puis droite), le parcours s&rsquo;apparente à celui appelé POSTFIXE.</p><figure><img src=../images/trifusion0.png alt="tri fusion"><figcaption>parcours de l'arbre pour le tri fusion</figcaption></figure><h2 id=etude-du-tri-fusion-sur-la-liste-l-1-10-8-4-3-6>Etude du tri fusion sur la liste L = [1,10,8,4,3,6]</h2><blockquote><p><strong>Question 1:</strong> <i>Compléter la séquence avec l&rsquo;ordre des branches parcourues et les sous-listes à chaque noeud, jusqu&rsquo;à ce que tout le sous-arbre gauche soit &ldquo;divisée&rdquo;</i>.</p></blockquote><p>La <strong>remontée</strong> dans la pile d&rsquo;appels commence lorsque l&rsquo;on arrive à une sous-liste d&rsquo;un seul élément pour <em>droite</em>.</p><p>La <strong>fonction <code>interclassement</code></strong> prend deux listes en paramètres, L1 et L2, et retourne une seule liste avec les éléments de L1 et L2, mais classés.</p><blockquote><p><strong>Question 2:</strong> <em>Décrire les étapes jusqu&rsquo;à ce que la liste L soit triée.</em></p></blockquote><p>La <strong>complexité</strong> de la fonction <code>interclassement</code> est O(n), où n est égal à la taille de chaque sous-liste.</p><blockquote><p><strong>Question 3:</strong> <em>Combien de fois cette fonction <code>interclassement</code> est-elle appelée pour la liste L de taille 6 vue en exemple?. Généraliser le résultat à celui d&rsquo;une liste L de taille N. En déduire la complexité du tri-fusion.</em></p></blockquote><h2 id=complexité-du-tri-fusion>Complexité du tri fusion</h2><p>Le tri fusion est un tri qui est <strong>optimal</strong> du point de vue de la complexité temporelle: il est de l&rsquo;ordre O(N*log(N)). On ne peut pas trouver un algorithme plus efficace en temps.</p><p>Par contre, cet algorithme demande beaucoup de ressources <em>spatiales</em>, du fait de la construction de nombreuses sous-listes pour réaliser le tri. Ce n&rsquo;est pas un <em>tri en place</em>, comme on a pu le voir avec les algorithmes essentiels vus en classe de 1ere NSI.</p><h1 id=liens>Liens</h1><ul><li>page wikipedia <a href=https://fr.wikipedia.org/wiki/Diviser_pour_régner_(informatique)>https://fr.wikipedia.org/wiki/Diviser_pour<em>régner</em>(informatique)</a></li><li>page wikipedia <a href=https://fr.wikipedia.org/wiki/Tri_fusion>https://fr.wikipedia.org/wiki/Tri_fusion</a></li><li>animation tri fusion <a href=http://lwh.free.fr/pages/algo/tri/tri_fusion.html>lwh.free</a></li></ul></article><div style=height:100px></div></div><aside class="book-toc fixed"><nav id=TableOfContents><ul><li><a href=#diviser-pour-regner>Diviser pour regner</a></li><li><a href=#exemple-introductif-te-le-phone-en-chai-ne>Exemple introductif : téléphone en chaîne</a></li><li><a href=#exponentiation>Exponentiation</a><ul><li><a href=#programme-itératif>Programme itératif</a></li><li><a href=#programme-récursif>Programme récursif</a></li><li><a href=#exponentiation-rapide-application-de-la-méthode-diviser-pour-regner>Exponentiation rapide : application de la méthode diviser pour regner</a></li></ul></li><li><a href=#le-tri-fusion>Le Tri Fusion</a><ul><li><a href=#principe>Principe</a></li><li><a href=#etude-du-tri-fusion-sur-la-liste-l-1-10-8-4-3-6>Etude du tri fusion sur la liste L = [1,10,8,4,3,6]</a></li><li><a href=#complexité-du-tri-fusion>Complexité du tri fusion</a></li></ul></li><li><a href=#liens>Liens</a></li></ul></nav></aside></main><div class=site_footer><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Licence Creative Commons" style=border-width:0 src=/creative.png></a>
<span xmlns:dct=http://purl.org/dc/terms/ property=dct:title>Sciences numeriques</span> de <a xmlns:cc=http://creativecommons.org/ns# href property=cc:attributionName rel=cc:attributionurl>numerix.netlify.com</a> est mis à disposition selon les termes de la <a rel=license href=http://creativecommons.org/licenses/by/4.0/>licence Creative Commons Attribution 4.0 International</a></div></body></html>