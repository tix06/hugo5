<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Complexité
| Sciences numériques</title><link href="https://fonts.googleapis.com/css?family=Oxygen|Oxygen+Mono:300,400,700" rel=stylesheet><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-167114468-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-167114468-1');</script><link rel=stylesheet href=/book.min.da08b24beb66dcf932637e18a4aa671dd07885404a58be6e3c0c3400afead4c9.css><link rel=icon href=/favicon.png type=image/x-icon><div class=my-header-container><div class=my-site-header><img src=/logo-site-b.svg width="150 px"></div><div id=myHeader><div class=titre><h2><a href=/>Sciences numériques</a></h2></div></div></div><script async>window.onload=function(){let container=document.getElementsByClassName("book-page");let logodiv=document.getElementsByClassName("site-menu-before");let header=document.getElementById("myHeader");let screen=window.innerWidth;let site_footer=document.querySelector(".site_footer");try{let site_TOC=document.querySelector("#TableOfContents>ul");let newP=document.createElement('li');newP.textContent='Contenu de la page';site_TOC.appendChild(newP,null);}
catch(err)
{console.log(err.message);}
if(site_footer.parentNode!=document.body){let father=site_footer.parentNode;let clone=site_footer.cloneNode;father.removeChild(site_footer);document.body.appendChild(clone);}
if(screen<=850){document.getElementsByClassName("my-site-header")[0].style.display="none";}else{window.addEventListener("scroll",function(e){let spectral=document.getElementById("spectral");if(screen>850){if(window.pageYOffset>150){header.classList.add("sticky");if(container.lenght>0){container[0].style.marginTop="65px";};logodiv[0].style.height="120px";}else{header.classList.remove("sticky");if(container.lenght>0){container[0].style.marginTop="0px";};spectral.style.display="none";logodiv[0].style.height="220px";}}
if(screen<=850){if(window.pageYOffset>150){spectral.style.display="block";}else{spectral.style.display="none";}}});}}</script></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav role=navigation><div class=site-menu-before style=height:220px;display:block><img src=/logo-site.svg id=spectral height=50% style=display:none></div><style>nav ul a[href$=\2f docs\2fNSI\2f algorithmes\2fpage1\2f ]{color:#004ed0}</style><ul><li><p><a href=/><strong>Accueil</strong></a></p></li><li><p><a href=/docs/PC_2nde/PC_index/><strong>Physique Chimie 2nde</strong></a></p><ul><li><a href=/docs/PC_2nde/physique/pages/page1/>physique du mouvement</a></li><li><a href=/docs/PC_2nde/physique/pages/page2/>échanges thermiques</a></li><li><a href=/docs/PC_2nde/chimie/pages/mole/>la mole</a></li><li><a href=/docs/PC_2nde/chimie/pages/transformation/>transformation chimique</a></li><li><a href=/docs/PC_2nde/chimie/pages/avancement/>animation avancement</a></li></ul></li><li><p><a href=/docs/PC_1ere/PC_index/><strong>Physique 1ere Spé</strong></a></p><ul><li><a href=/docs/PC_1ere/energie/energie1/>Energie</a></li><li><a href=/docs/PC_1ere/atome/atome/>modèle de Bohr de l&rsquo;atome</a></li><li><a href=/docs/PC_1ere/notebooks/PC_notebooks/>ipython notebooks</a></li></ul></li><li><p><a href=/docs/NSI/NSI_index/><strong>NSI</strong></a></p><ul><li><a href=/docs/NSI/NSI_architecture/>architecture informatique</a></li><li><a href=/docs/NSI/NSI_structure/>structure de données</a></li><li><a href=/docs/NSI/NSI_bases/>bases de données</a></li><li><a href=/docs/NSI/NSI_langages/>langages</a></li><li><a href=/docs/NSI/NSI_algorithmes/>algorithmes</a><br></li></ul></li><li><p><a href=/docs/SNT_2nde/SNT_index/><strong>SNT secondes</strong></a></p></li><li><p><a href=/posts/><strong>Posts</strong></a></p></li><li><p><a href=/docs/contact/simple-contact-form/><strong>Contact</strong></a></p></li></ul></nav><script>(function(){var menu=document.querySelector('aside.book-menu nav')
addEventListener('beforeunload',function(event){localStorage.setItem('menu.scrollTop',menu.scrollTop)});menu.scrollTop=localStorage.getItem('menu.scrollTop')})()</script></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg alt=Menu></label>
<strong>Complexité</strong></header><article class=markdown><h1 id=cout-spatial-et-temporel>cout spatial et temporel</h1><h2 id=complexité-temporelle>Complexité temporelle</h2><p>L&rsquo;execution d&rsquo;un algorithme nécessite l&rsquo;utilisation des ressources de l&rsquo;ordinateur :</p><ul><li>complexité en temps : temps de calcul pour executer les operations. On supposera qu&rsquo;il correspond au nombre d&rsquo;opérations effectuées par le programme.</li><li>complexité spatiale : occupation de la mémoire pour contenir et manipuler le programme et ses données. Peut s&rsquo;exprimer en nombre de mots mémoires.</li></ul><p>Pour evaluer la complexité temporelle, on peut mettre en evidence plusieurs opérations fondamentales. Le temps d&rsquo;éxecution d&rsquo;un algorithme resolvant ce genre de problème est toujours proportionnel au nombre de ces opérations :</p><p>Pour le tri, par exemple : ces opérations fondamentales sont le nombre de comparaisons entre 2 élements et le nombre de deplacements de ces élements.</p><h2 id=complexité-spatiale>Complexité spatiale</h2><p>Il faut souvent définir une mesure sur les données qui réflète la quantité d&rsquo;informations contenues. Exemple : nombre de chiffre des nombres, le nombre d&rsquo;éléments manipulés, dimension d&rsquo;une matrice, nombre de noeuds d&rsquo;un graphe&hellip;
C&rsquo;est la complexité spatiale.</p><h1 id=evaluer-la-complexité-temporelle>Evaluer la complexité (temporelle)</h1><p>La complexité d’un algorithme sera (sauf mention contraire) exprimée sous la forme : <em>O</em>(<em>g</em>(<em>n</em>)). Il s&rsquo;agira d&rsquo;estimer, le plus souvent, la complexité dans le pire des cas (sa borne supérieure), ou bien, lorsque cela est pertinent, la complexité asymptotique.</p><p>En pratique, on ne comptera que les opérations estimées <strong>importantes</strong> : celles qui ne changent pas selon les nuances du langage utilisées lors de la programmation (boucle while et boucle for&hellip;) mais qui changent selon le problème.</p><p>Voici le principe de base pour calculer la complexité d’une boucle bornée. Soit (deb,fin) ∈ Z<sup>2</sup>, considérons une boucle de type <code>for i in range(deb, fin):</code></p><p>Alors la complexité de cette boucle est :
$$\sum_{i=deb}^{fin-1} C_i$$
où C représente la complexité de l’itération<sup class=footnote-ref id=fnref:2><a href=#fn:2>1</a></sup> i</p><p>Le principe est le même pour une boucle bornée (non conditionnelle), mais il est moins facile de déterminer le nombre d’itérations de la boucle. Pour ce faire, la méthode classique est d’étudier plus en détails le variant de boucle déjà utilisé pour prouver la terminaison de la boucle. On détermine :</p><ul><li>La valeur initiale du variant de boucle ;</li><li>Sa valeur finale ;</li><li>De combien il diminue strictement à chaque étape.</li></ul><p>on peut alors en déduire le nombre d’itérations de la boucle.</p><p>On utilise les notations de <strong>Landau :</strong></p><ul><li><strong>Notation O : la borne superieure :</strong> g domine f
on note f = O(g) s&rsquo;il existe un nombre réel positif a et un rang n de f<sub>n</sub> tels que f(n) ≤ a.g(n) :</li></ul><p>$$\exists c \in \mathbb{R}^+, tels \quad que\quad \forall n_o \in \mathbb{N}, |f(n_o)|\leq c.|g(n)| $$</p><p>En pratique, la recherche de la complexité revient à déterminer cette fonction (ou cette suite) g. On note la complexité <strong>O(g)</strong>. On ignore l&rsquo;eventuel coefficient multiplicateur c et on ne conserve que le terme le plus divergent dans le cas où g contienne plusieurs termes. <strong>T(n) = O(g(n))</strong>.</p><ul><li><p><strong>Notation &Theta; :</strong> Lorsqu&rsquo;il est possible de déterminer une fonction asymptotique de la complexité, la notation devient &Theta;(g).</p></li><li><p>Principales classes de la complexité :*
Ces complexités sont classées par temps d&rsquo;execution croissant de l&rsquo;agorithme correspondant.</p></li></ul><table><thead><tr><th>complexité</th><th>classe</th></tr></thead><tbody><tr><td>&Theta;(1)</td><td>temps constant</td></tr><tr><td>&Theta;(log n)</td><td>logarithmique</td></tr><tr><td>&Theta;(n)</td><td>linéaire</td></tr><tr><td>&Theta;(n*log n)</td><td>quasi linéaire</td></tr><tr><td>&Theta;(n<sup>2</sup>)</td><td>quadratique, polynômial</td></tr><tr><td>&Theta;(n<sup>3</sup>)</td><td>cubique, polynômial</td></tr><tr><td>&Theta;(2<sup>n</sup>)</td><td>exponentiel (problème très difficiles)</td></tr></tbody></table><h1 id=exemple-1-la-recherche-dans-une-liste-triée>Exemple 1 : la recherche dans une liste triée</h1><h2 id=enoncé-du-problème-1>Enoncé du problème<sup class=footnote-ref id=fnref:1><a href=#fn:1>2</a></sup></h2><p>Supposons que le problème posé soit de trouver un nom X dans un annuaire téléphonique qui consiste en une liste triée alphabétiquement. On peut s&rsquo;y prendre de plusieurs façons différentes. En voici deux :</p><ol><li>Recherche linéaire : parcourir les pages dans l&rsquo;ordre (alphabétique) jusqu&rsquo;à trouver le nom X cherché. C&rsquo;est l&rsquo;algorithme de lecture exhaustif, aussi appelé algorithme de recherche linéaire.</li><li>Recherche dichotomique : ouvrir l&rsquo;annuaire au milieu, si le nom qui s&rsquo;y trouve est plus loin alphabétiquement que le nom cherché, regarder avant, sinon, regarder après. Refaire l&rsquo;opération qui consiste à couper les demi-annuaires (puis les quarts d&rsquo;annuaires, puis les huitièmes d&rsquo;annuaires, etc.) jusqu&rsquo;à trouver le nom cherché.</li></ol><h2 id=algorithme-de-lecture-exhaustif-recherche-linéaire>Algorithme de lecture exhaustif (recherche linéaire)</h2><p>Cet algorithme pourrait fonctionner même si les mots sont rangés dans le désordre : il s&rsquo;agit de parcourir tous les mots, du premier au dernier, jusqu&rsquo;à tomber sur le mot recherché dans cet annuaire.</p><h3 id=complexité>Complexité</h3><p>Pour chacune de ces méthodes il existe un <strong>pire</strong> des cas et un <strong>meilleur</strong> des cas.</p><ul><li>Dans le meilleur des cas, le nom X est trouvé dès l&rsquo;ouverture de l&rsquo;annuaire: il n&rsquo;y aura alors qu&rsquo;<strong>une seule étape</strong>.</li><li>Supposons que l&rsquo;annuaire contienne N = 30 000 noms, si le mot recherché est le dernier du dictionnaire, le pire cas, cela demandera 30 000 étapes. La complexité est proportionnelle au nombre <strong>N</strong>. On la note <strong>O(N)</strong>, ça veut dire que dans le pire des cas, le temps de calcul est de l&rsquo;ordre de grandeur de N.</li></ul><h3 id=détail-des-opérations-réalisées>Détail des opérations réalisées</h3><p>Les <strong>éléments significatifs</strong> pour analyser la complexité en nombre d&rsquo;opérations sont :</p><ul><li>le nombre d&rsquo;itérations</li><li>le nombre d&rsquo;opérations par itération</li></ul><p>L&rsquo;instruction <code>j←j+1</code> est dépendante du type de boucle, par exemple, while ≠ for. Elle disparait si on programme différemment.</p><p>Il en est de même pour la comparaison <code>j≤n</code> : il ne faudra pas les prendre en compte pour évaluer l&rsquo;algorithme.</p><p>Les opérations significatives sont donc les comparaisons de X avec les elements de la liste : il en existe une par itération.</p><h3 id=invariant-de-boucle-et-condition-d-arrêt>Invariant de boucle et condition d&rsquo;arrêt</h3><p>L&rsquo;analyse se fait en établissant des <strong>invariants de boucle</strong>, c&rsquo;est à dire des propositions qui sont vraies à chaque itération, et des <strong>conditions d&rsquo;arrêt</strong>.</p><ul><li><p>invariant de boucle : au debut de la première itération, j=1. Et au début de la kieme itération, j=k et L[i]≠X</p></li><li><p>condition d&rsquo;arrêt : si au debut de la kieme itération de la boucle on a : k≤ n et L[k]=X, alors on s&rsquo;arrête avec j=k; si on a k=n+1, alors on va s&rsquo;arrêter avec j=0.</p></li></ul><p><em>Remarque :</em> La complexité dépend de la taille des données, mais aussi, pour une taille fixée, des différentes données possibles, de leur possible redondance.</p><ul><li><p><strong>Complexité dans le meilleur et le pire des cas:</strong> La complexité se situe entre</p><ul><li>Min(n) = 1 : meilleur des cas</li><li>et Max(n) = n : pire des cas</li></ul></li><li><p><strong>Complexité en moyenne:</strong></p></li></ul><p>$$Moy_A(n) = \sum_{d \in D_n} p(d).coût_A(d)$$</p><p>où p(d) est la probabilité que l&rsquo;on ait la donnée d en entrée de l&rsquo;algorithme.</p><p>et coût_A(d) représente la complexité en temps de l&rsquo;algorithme A sur la donnée d.</p><h2 id=algorithme-de-recherche-dichotomique>Algorithme de recherche dichotomique</h2><h3 id=programme-python>Programme python</h3><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>rechDichoAux</span><span style=color:#111>(</span><span style=color:#111>tabTrie</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>,</span><span style=color:#111>debut</span><span style=color:#111>,</span><span style=color:#111>fin</span><span style=color:#111>):</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>debut</span> <span style=color:#f92672>==</span> <span style=color:#111>fin</span> <span style=color:#111>:</span>
        <span style=color:#00a8c8>if</span> <span style=color:#111>tabTrie</span><span style=color:#111>[</span><span style=color:#111>debut</span><span style=color:#111>]</span> <span style=color:#f92672>==</span> <span style=color:#111>x</span><span style=color:#111>:</span>
            <span style=color:#00a8c8>return</span> <span style=color:#111>debut</span>
        <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
            <span style=color:#00a8c8>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
        <span style=color:#111>milieu</span><span style=color:#f92672>=</span> <span style=color:#111>(</span><span style=color:#111>fin</span><span style=color:#f92672>-</span><span style=color:#111>debut</span><span style=color:#111>)</span><span style=color:#f92672>//</span><span style=color:#ae81ff>2</span>
        <span style=color:#00a8c8>if</span> <span style=color:#111>x</span> <span style=color:#f92672>&lt;=</span> <span style=color:#111>tabTrie</span><span style=color:#111>[</span><span style=color:#111>debut</span><span style=color:#f92672>+</span><span style=color:#111>milieu</span><span style=color:#111>]:</span>
            <span style=color:#00a8c8>return</span> <span style=color:#111>rechDichoAux</span><span style=color:#111>(</span><span style=color:#111>tabTrie</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>,</span><span style=color:#111>debut</span><span style=color:#111>,</span><span style=color:#111>debut</span><span style=color:#f92672>+</span><span style=color:#111>milieu</span><span style=color:#111>)</span>
        <span style=color:#00a8c8>else</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>rechDichoAux</span><span style=color:#111>(</span><span style=color:#111>tabTrie</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>,</span><span style=color:#111>debut</span><span style=color:#f92672>+</span><span style=color:#111>milieu</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>fin</span><span style=color:#111>)</span>

<span style=color:#00a8c8>def</span> <span style=color:#75af00>rechDich</span><span style=color:#111>(</span><span style=color:#111>tab</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>):</span>
    <span style=color:#111>n</span><span style=color:#f92672>=</span><span style=color:#111>len</span><span style=color:#111>(</span><span style=color:#111>tab</span><span style=color:#111>)</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>rechDichoAux</span><span style=color:#111>(</span><span style=color:#111>tab</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>,</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span></code></pre></div><p>On peut alors tester le programme (jupyter notebook):</p><table><tr><th scope=row>IN</th><td>tab = [23, 34, 45, 56, 67, 104]<br>rechDich(tab,67)</td></tr><tr><th scope=row>OUT</th><td>4</td></tr></table><h3 id=complexité-1>Complexité</h3><p>Le second algorithme demandera dans le pire des cas de séparer en deux l&rsquo;annuaire, puis de séparer à nouveau cette sous-partie en deux, ainsi de suite jusqu&rsquo;à n&rsquo;avoir qu&rsquo;un seul nom. Le nombre d&rsquo;étapes nécessaire sera le nombre entier qui est immédiatement plus grand que log<sub>2</sub>(N), qui vaut 15 lorsque N=30 000.</p><p>La complexité est alors O(log<sub>2</sub>(N))</p><h1 id=exemple-2-multiplication-de-matrices-carrées>Exemple 2 : multiplication de matrices carrées</h1><h2 id=enoncé-du-problème>Enoncé du problème</h2><p>soit A = (a<sub>ij</sub>) et B = (b<sub>ij</sub>) deux matrices n*n à coefficients dans <strong>R</strong>.</p><p>i = numero de ligne et j = colonne</p><p>L&rsquo;algorithme suivant devra calculer les coefficients (c i j) de la matrice C = A*B selon la formule :</p><p>$$c_{ij} = \sum_{k=1}^n a_{ik}.b_{kj}$$</p><h2 id=algorithme>Algorithme</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>import</span> <span style=color:#111>numpy</span> <span style=color:#f92672>as</span> <span style=color:#111>np</span>
<span style=color:#00a8c8>def</span> <span style=color:#75af00>matrice</span><span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    calcule et retourne la matrice c produit des matrices a*b
</span><span style=color:#d88200>    a et b sont supposées être des matrices carrées, de même dimension
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>nblignes</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span><span style=color:#f92672>.</span><span style=color:#111>shape</span><span style=color:#111>[</span><span style=color:#ae81ff>0</span><span style=color:#111>]</span>
    <span style=color:#111>nbcolonnes</span> <span style=color:#f92672>=</span> <span style=color:#111>b</span><span style=color:#f92672>.</span><span style=color:#111>shape</span><span style=color:#111>[</span><span style=color:#ae81ff>1</span><span style=color:#111>]</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>nblignes</span> <span style=color:#f92672>!=</span> <span style=color:#111>nbcolonnes</span><span style=color:#111>:</span>
        <span style=color:#00a8c8>raise</span> <span style=color:#d88200>&#34;value error !&#34;</span>
    <span style=color:#111>c</span> <span style=color:#f92672>=</span> <span style=color:#111>np</span><span style=color:#f92672>.</span><span style=color:#111>zeros</span><span style=color:#111>(</span><span style=color:#111>nblignes</span><span style=color:#f92672>*</span><span style=color:#111>nbcolonnes</span><span style=color:#111>)</span><span style=color:#f92672>.</span><span style=color:#111>reshape</span><span style=color:#111>(</span><span style=color:#111>nblignes</span><span style=color:#111>,</span><span style=color:#111>nbcolonnes</span><span style=color:#111>)</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#111>nblignes</span><span style=color:#111>):</span>
        <span style=color:#00a8c8>for</span> <span style=color:#111>j</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#111>nbcolonnes</span><span style=color:#111>):</span>
            <span style=color:#00a8c8>for</span> <span style=color:#111>k</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#111>nbcolonnes</span><span style=color:#111>):</span>
                <span style=color:#111>c</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>,</span><span style=color:#111>j</span><span style=color:#111>]</span> <span style=color:#f92672>+=</span> <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>,</span><span style=color:#111>k</span><span style=color:#111>]</span><span style=color:#f92672>*</span><span style=color:#111>b</span><span style=color:#111>[</span><span style=color:#111>k</span><span style=color:#111>,</span><span style=color:#111>j</span><span style=color:#111>]</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>c</span></code></pre></div><p>Voici un exemple d&rsquo;utilisation de ce programme (avec jupyter notebook) :</p><table><tr><th scope=row>IN</th><td>M1 = np.matrix((1,2,3,4,5,6,7,8,9)).reshape(3,3)<br>M2 = np.matrix((2,4,6,8,10,12,14,16,18)).reshape(3,3)<br>matrice(M1,M2)</td></tr><tr><th scope=row>OUT</th><td>$$\begin{align}
array([&[60.&, 72.&, 84.],\\
&[132.&, 162.&, 192.],\\
&[204.&, 252.&, 300.]])\\
\end{align}$$</td></tr></table><h2 id=complexité-2>Complexité</h2><p>La complexité de l&rsquo;algorithme matrice, comptée en nombre de multiplications de réels ne dépend que de la taille des matrices :</p><ul><li><p>Le nombre de multiplication est :
$$\sum_{i=1}^n \sum_j \sum_k 1 = n^3 $$</p></li><li><p>Le nombre d&rsquo;additions est :
$$n^2(n-1)$$</p></li><li><p>La complexité asymptotique est alors :
$$Min(n) = Max(n) = Moy(n) = n^3 $$</p></li></ul><h1 id=exercices>Exercices</h1><h2 id=exercice-1>Exercice 1</h2><p>Déterminer la complexité des fonctions suivantes en terme de nombre d’additions et de soustractions. On donnera d’abord la valeur exacte T(n) puis l’ordre de grandeur O(n).</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>truc</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span> 
  <span style=color:#111>res</span><span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#111>):</span> 
    <span style=color:#111>res</span> <span style=color:#f92672>+=</span><span style=color:#ae81ff>1</span>
  <span style=color:#00a8c8>return</span> <span style=color:#111>res</span>


<span style=color:#00a8c8>def</span> <span style=color:#75af00>machin</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
  <span style=color:#111>res</span><span style=color:#f92672>=</span><span style=color:#111>truc</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>)</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#111>):</span>
    <span style=color:#111>res</span> <span style=color:#f92672>-=</span><span style=color:#ae81ff>1</span> 
  <span style=color:#00a8c8>return</span> <span style=color:#111>res</span>

<span style=color:#00a8c8>def</span> <span style=color:#75af00>chose</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
  <span style=color:#111>res</span><span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
    <span style=color:#111>res</span><span style=color:#f92672>+=</span><span style=color:#111>machin</span><span style=color:#111>(</span><span style=color:#111>i</span><span style=color:#111>)</span> 
  <span style=color:#00a8c8>return</span> <span style=color:#111>res</span>

<span style=color:#00a8c8>def</span> <span style=color:#75af00>fonctionFinale</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
  <span style=color:#111>res</span> <span style=color:#f92672>=</span><span style=color:#111>[]</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#111>):</span>
    <span style=color:#111>res</span><span style=color:#f92672>.</span><span style=color:#111>append</span><span style=color:#111>(</span><span style=color:#111>chose</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>))</span> 
  <span style=color:#00a8c8>return</span> <span style=color:#111>res</span></code></pre></div><h2 id=exercice-2-polynôme-de-horner>Exercice 2 : polynôme de Horner</h2><p>Soit x ∈ R. On souhaite calculer 3x<sup>2</sup> + 2x + 1.</p><p>On propose dans un un premier temps, un algorithme <em>naîf</em>, qui calcule les puissances au fur et à mesure des itérations dans la boucle :</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>poly</span><span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    fonction qui calcule la valeur d&#39;un polynôme en x
</span><span style=color:#d88200>    a : liste des coefficients du polynôme de dimension quelconque
</span><span style=color:#d88200>    x : valeur à renseigner
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>c</span><span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
    <span style=color:#111>p</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#111>len</span><span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>)):</span>
        <span style=color:#111>c</span> <span style=color:#f92672>+=</span> <span style=color:#111>a</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>]</span> <span style=color:#f92672>*</span> <span style=color:#111>p</span>
        <span style=color:#111>p</span> <span style=color:#f92672>*=</span> <span style=color:#111>x</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>c</span></code></pre></div><ol><li><p>Déterminer la liste des coefficients <code>a</code> qu&rsquo;il faudra renseigner avant d&rsquo;appeller la fonction <code>poly</code>.</p></li><li><p>Calculer le nombre d&rsquo;additions et de multiplications qui sont réalisées par cette fonction, lorsque le polynôme est 3x<sup>2</sup> + 2x + 1.</p></li><li><p>Généraliser ce calcul pour un polynôme de degré n, où n serait la longueur de la liste a.</p></li><li><p>Deuxième exemple : pour 3x<sup>3</sup> + 2x<sup>2</sup> − x + 7 : mettre l&rsquo;expression sous une forme nécessitant trois multiplications. (s&rsquo;aider de l&rsquo;écriture de P(x) plus bas)</p></li><li><p>Soit x ∈ R, soit P un polynôme, soit n son degré, a<sub>0</sub>, &hellip;, a<sub>n</sub> ses coefficients. On écrit P (x) sous la forme :
􏰃􏰁$$P(x) = a_0 + x\times(a_1+x\times(a_2+x\times(a_3+&hellip;x\times(a_n)&hellip;)))$$
Écrire un algorithme pour calculer P(x) selon cette méthode. (méthode de Horner)<br>Combien de multiplications sont effectuées pour calculer P(x) avec cet algorithme ?</p></li></ol><h2 id=exercice-3-calcul-de-la-complexité-en-moyenne>Exercice 3 : calcul de la complexité en moyenne</h2><p>On considère une liste de 4 éléments, différents, mis dans un tableau aux rangs 1 à 4.</p><p>Si on cherche une valeur X aléatoire dans ce tableau par une méthode itérative, et que l&rsquo;on fait 16 essais, il y a de plus nombreuses chances que l&rsquo;on ait des résultats équiprobables :</p><table><thead><tr><th>n° essai</th><th>valeur aléatoire cherchée X</th><th>parcours de la liste</th><th>nombre de comparaisons T</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>1</td><td>1</td></tr><tr><td>3</td><td>1</td><td>1</td><td>1</td></tr><tr><td>4</td><td>1</td><td>1</td><td>1</td></tr><tr><td>5</td><td>2</td><td>1 -&gt; 2</td><td>2</td></tr><tr><td>6</td><td>2</td><td>1 -&gt; 2</td><td>2</td></tr><tr><td>7</td><td>2</td><td>1 -&gt; 2</td><td>2</td></tr><tr><td>8</td><td>2</td><td>1 -&gt; 2</td><td>2</td></tr><tr><td>9</td><td>3</td><td>1 -&gt; 2 -&gt; 3</td><td>3</td></tr><tr><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td><td>&hellip;</td></tr><tr><td>16</td><td>4</td><td>1 -&gt; 2 -&gt; 3 -&gt; 4</td><td>4</td></tr></tbody></table><p>On supposera que X est bien présent dans le tableau.</p><ol><li>Déterminer le nombre total de comparaisons qui sont faites avec 16 essais.</li><li>Déterminer le nombre moyen de comparaisons qui sont effectuées.</li><li>Généraliser le résultat à un tableau comprenant n éléments, équiprobables, de probabilité p. Montrer que l&rsquo;on trouve :
$$T(n) = p \times \tfrac{n(n+1)}{2}$$ (somme des termes d&rsquo;une suite arithmétique)</li><li>Déterminer alors que la compléxité &Theta; de l&rsquo;algorithme de recherche itérative est linéaire en n.</li></ol><h2 id=exercice-4>Exercice 4 :</h2><p>Vous êtes face à un mur qui s’étend à l’infini dans les deux directions. Il y a une porte dans ce 􏰒􏰑
mur, mais vous ne connaissez ni la distance, ni la direction dans laquelle elle se trouve. Par ailleurs, l’obscurité vous empêche de voir la porte à moins d’être juste devant elle.
Décrire un algorithme vous permettant de trouver cette porte en un temps linéaire vis-à-vis de la distance qui vous sépare de celle-ci.</p><h2 id=exercice-5>Exercice 5 :</h2><p>Dans un groupe de n individus , une star est quelqu’un que tout le monde connait mais qui ne 􏰒􏰑
connait personne. Pour trouver une star, s’il en existe une, vous ne pouvez poser aux individus de ce groupe que des questions du type : « connaissez-vous x ? ».
Combien de stars au maximum peut-il exister dans un groupe ?
Donner un algorithme trouvant une star s’il en existe une (ou déterminant qu’il n’en existe pas) et de coût linéaire (en prenant comme mesure de la complexité le nombre de questions posées).</p><h2 id=exercice-6>Exercice 6 :</h2><p>Le problème est de déterminer à partir de quel étage d’un immeuble sauter par une fenêtre est 􏰒􏰑
fatal. Vous êtes dans un immeuble à n étages (numérotés de 1 à n) et vous disposez de k étudiants. Il n’y a qu’une opération possible pour tester si la hauteur d’un étage est fatale : faire sauter un étudiant par la fenêtre. S’il survit, vous pouvez le réutiliser ensuite, sinon vous ne pouvez plus.
Vous devez proposer un algorithme pour trouver la hauteur à partir de laquelle un saut est fatal en faisant le minimum de sauts.</p><p><em>Donnée :</em> on suppose k &gt; log n</p><h1 id=corrections>Corrections</h1><h2 id=correction-de-l-ex-2>correction de l&rsquo;ex 2</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>PHorner</span><span style=color:#111>(</span><span style=color:#111>taba</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    calcul de la valeur de l&#39;expression polynome avec la methode 
</span><span style=color:#d88200>    de Horner
</span><span style=color:#d88200>    taba : tableau des coefficient a_i
</span><span style=color:#d88200>    x : valeur de x
</span><span style=color:#d88200>    sortie : P(X)=a0.1 + a1.X + a2.X^2 + ... an.X^n
</span><span style=color:#d88200>    sans utiliser ** pour la puissance
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>v</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># variable accumulateur</span>
    <span style=color:#111>n</span> <span style=color:#f92672>=</span> <span style=color:#111>len</span><span style=color:#111>(</span><span style=color:#111>taba</span><span style=color:#111>)</span> <span style=color:#75715e># longueur tableau</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>):</span>
        <span style=color:#111>v</span> <span style=color:#f92672>=</span> <span style=color:#111>v</span> <span style=color:#f92672>*</span> <span style=color:#111>x</span> <span style=color:#f92672>+</span> <span style=color:#111>taba</span><span style=color:#111>[</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#111>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>]</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>v</span></code></pre></div><p>On peut alors tester le programme (jupyter notebook):</p><table><tr><th scope=row>IN</th><td>tab = [0,1,2]<br>PHorner(tab,3)</td></tr><tr><th scope=row>OUT</th><td>7</td></tr></table><div class=footnotes><hr><ol><li id=fn:2>itération : succession d&rsquo;états dans un processus
<a class=footnote-return href=#fnref:2><sup>[return]</sup></a></li><li id=fn:1>wikipedia : analyse de la complexité : <a href=https://fr.wikipedia.org/wiki/Analyse_de_la_complexité_des_algorithmes>https://fr.wikipedia.org/wiki/Analyse_de_la_complexité_des_algorithmes</a>
<a class=footnote-return href=#fnref:1><sup>[return]</sup></a></li></ol></div></article><div style=height:100px></div></div><aside class="book-toc fixed"><nav id=TableOfContents><ul><li><a href=#cout-spatial-et-temporel>cout spatial et temporel</a><ul><li><a href=#complexité-temporelle>Complexité temporelle</a></li><li><a href=#complexité-spatiale>Complexité spatiale</a></li></ul></li><li><a href=#evaluer-la-complexité-temporelle>Evaluer la complexité (temporelle)</a></li><li><a href=#exemple-1-la-recherche-dans-une-liste-triée>Exemple 1 : la recherche dans une liste triée</a><ul><li><a href=#enoncé-du-problème-1>Enoncé du problème<sup class=footnote-ref id=fnref:1><a href=#fn:1>2</a></sup></a></li><li><a href=#algorithme-de-lecture-exhaustif-recherche-linéaire>Algorithme de lecture exhaustif (recherche linéaire)</a><ul><li><a href=#complexité>Complexité</a></li><li><a href=#détail-des-opérations-réalisées>Détail des opérations réalisées</a></li><li><a href=#invariant-de-boucle-et-condition-d-arrêt>Invariant de boucle et condition d&rsquo;arrêt</a></li></ul></li><li><a href=#algorithme-de-recherche-dichotomique>Algorithme de recherche dichotomique</a><ul><li><a href=#programme-python>Programme python</a></li><li><a href=#complexité-1>Complexité</a></li></ul></li></ul></li><li><a href=#exemple-2-multiplication-de-matrices-carrées>Exemple 2 : multiplication de matrices carrées</a><ul><li><a href=#enoncé-du-problème>Enoncé du problème</a></li><li><a href=#algorithme>Algorithme</a></li><li><a href=#complexité-2>Complexité</a></li></ul></li><li><a href=#exercices>Exercices</a><ul><li><a href=#exercice-1>Exercice 1</a></li><li><a href=#exercice-2-polynôme-de-horner>Exercice 2 : polynôme de Horner</a></li><li><a href=#exercice-3-calcul-de-la-complexité-en-moyenne>Exercice 3 : calcul de la complexité en moyenne</a></li><li><a href=#exercice-4>Exercice 4 :</a></li><li><a href=#exercice-5>Exercice 5 :</a></li><li><a href=#exercice-6>Exercice 6 :</a></li></ul></li><li><a href=#corrections>Corrections</a><ul><li><a href=#correction-de-l-ex-2>correction de l&rsquo;ex 2</a></li></ul></li></ul></nav></aside></main><div class=site_footer><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Licence Creative Commons" style=border-width:0 src=/creative.png></a>
<span xmlns:dct=http://purl.org/dc/terms/ property=dct:title>Sciences numeriques</span> de <a xmlns:cc=http://creativecommons.org/ns# href property=cc:attributionName rel=cc:attributionurl>numerix.netlify.com</a> est mis à disposition selon les termes de la <a rel=license href=http://creativecommons.org/licenses/by/4.0/>licence Creative Commons Attribution 4.0 International</a></div></body></html>