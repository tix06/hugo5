<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>calculer sur un algorithme
| Sciences numériques</title><link href="https://fonts.googleapis.com/css?family=Oxygen|Oxygen+Mono:300,400,700" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" rel=stylesheet><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-167114468-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-167114468-1');</script><link rel=stylesheet href=/book.min.32802dced2d04a5a7553a22b5967b5f4538a6110e52a9b615a3ed5ee836e87c1.css><link rel=icon href=/favicon.png type=image/x-icon><div class=my-header-container><div class=my-site-header><img src=/logo-site-b.svg width="150 px"></div><div id=myHeader><div class=titre><h2><a href=/>Sciences numériques</a></h2></div></div></div><script async>window.onload=function(){let container=document.getElementsByClassName("book-page");let logodiv=document.getElementsByClassName("site-menu-before");let header=document.getElementById("myHeader");let screen=window.innerWidth;let site_footer=document.querySelector(".site_footer");try{let site_TOC=document.querySelector("#TableOfContents>ul");let newP=document.createElement('li');newP.textContent='Contenu de la page';site_TOC.appendChild(newP,null);}
catch(err)
{console.log(err.message);}
if(site_footer.parentNode!=document.body){let father=site_footer.parentNode;let clone=site_footer.cloneNode;father.removeChild(site_footer);document.body.appendChild(clone);}
if(screen<=850){document.getElementsByClassName("my-site-header")[0].style.display="none";}else{window.addEventListener("scroll",function(e){let spectral=document.getElementById("spectral");if(screen>850){if(window.pageYOffset>150){header.classList.add("sticky");if(container.lenght>0){container[0].style.marginTop="65px";};logodiv[0].style.height="120px";}else{header.classList.remove("sticky");if(container.lenght>0){container[0].style.marginTop="0px";};spectral.style.display="none";logodiv[0].style.height="220px";}}
if(screen<=850){if(window.pageYOffset>150){spectral.style.display="block";}else{spectral.style.display="none";}}});}}
let chemin=window.location.pathname;if(chemin.search('NSI')>-1){baniere=document.querySelector("#myHeader");let linkBox=document.createElement('div');linkBox.classList.add('linkBox');let newH=document.createElement('a');newH.innerHTML='<a href="/docs/NSI/NSI_index/index.html">NSI</a>';newH.classList.add('nsi');linkBox.appendChild(newH);baniere.appendChild(linkBox);}</script><style>#myHeader{display:flex;flex-direction:row-reverse}#myHeader>.titre{width:80%;min-width:300px;text-align:left}.linkBox{margin:10px;padding-top:10px;background-color:pink;min-width:50px}.isn{}</style></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav role=navigation><div class=site-menu-before style=height:220px;display:block><img src=/logo-site.svg id=spectral height=50% style=display:none></div><style>nav ul a[href$=\2f docs\2fNSI\2f algorithmes\2fpage2\2f ]{color:#004ed0}</style><ul><li><a href=/><strong>Accueil</strong></a></li><li><a href=/docs/esf/esf_index/><strong>ESF</strong></a></li><li><p><a href=/docs/SNT_2nde/SNT_index/><strong>SNT secondes</strong></a></p></li><li><p><a href=/docs/NSI/NSI_index/><strong>NSI</strong></a></p><ul><li><a href=/docs/NSI/NSI_architecture/>architecture informatique</a></li><li><a href=/docs/NSI/NSI_structure/>structure de données</a></li><li><a href=/docs/NSI/NSI_bases/>bases de données</a></li><li><a href=/docs/NSI/NSI_langages/>langages</a></li><li><a href=/docs/NSI/NSI_algorithmes/>algorithmes</a><br></li></ul></li><li><p><a href=/docs/python/index_python/><strong>Python</strong></a></p></li><li><p><a href=/docs/PC_2nde/PC_index/><strong>Physique Chimie 2nde</strong></a></p></li><li><p><a href=/docs/PC_1ere/PC_index/><strong>Physique 1ere Spé</strong></a></p></li><li><p><a href=/posts/><strong>Posts</strong></a></p></li><li><p><a href=/docs/contact/simple-contact-form/><strong>Contact</strong></a></p></li></ul></nav><script>(function(){var menu=document.querySelector('aside.book-menu nav')
addEventListener('beforeunload',function(event){localStorage.setItem('menu.scrollTop',menu.scrollTop)});menu.scrollTop=localStorage.getItem('menu.scrollTop')})()</script></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg alt=Menu></label>
<strong>calculer sur un algorithme</strong></header><article class=markdown><h1 id=calculabilité>Calculabilité</h1><p>Dans le chapitre précédent, sur la complexité, l’objet d’étude principal etait l’algorithme. On en a fait une mesure de son efficacité: un algorithme est plus efficace s&rsquo;il est plus rapide (donc de classe de complexité plus faible).</p><p>En calculabilité, le problème devient l’objet central.</p><p>On a souvent l&rsquo;impression que pour chaque problème on peut trouver un algorithme de solution. Ce n&rsquo;est pas le cas : pour des nombreux probèmes naturels et intéressants il n’existe pas d’algorithme. Ces problèmes sont non calculables. Cette notion a évolué dans l&rsquo;histoire de l&rsquo;informatique au cours des étapes suivantes:</p><p><strong>Charles Babbage</strong> (1791 – 1871), professeur à Cambridge, construit la machine différentielle et la machine analytique. La dernière peut être considérée comme précurseur des ordinateurs modernes, consistant d’une unité de contrôle, une unité de calcul, une mémoire, ainsi que l’entrée-sortie.</p><figure><div><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/Charles_Babbage_-_1860.jpg/440px-Charles_Babbage_-_1860.jpg></div><figcaption>Charles Babbage (1791 – 1871)</figcaption></figure><p><strong>Ada Lovelace</strong> (1815 – 1852) travaille avec Babbage et préconise l’utilisation de la machine analytique pour la résolution de problèmes mathématiques. Elle est considérée comme premier programmeur du monde.</p><p><strong>David Hilbert</strong> (1862 – 1943), professeur à Göttingen, présente en 1920 un programme de recherche visant à clarifier les fondaments des mathématiques : “tout enoncé mathématique peut être soit prouvé ou refuté”. Plus tard il enonce le “Entscheidungsproblem” : montrer de façon “mécanique” si un enoncé mathématique est vrai ou faux.</p><p><strong>Kurt Gödel</strong> (1906 – 1978), un des logiciens les plus fameux de l’histoire, répond en 1931 négativement quand au programme proposé par Hilbert, en montrant que tout système formel suffisamment puissant est soit incomplet ou incohérent. Il montre ceci en construisant une formule qui exprime le fait qu’elle n’est pas démontrable (&ldquo;codage de Gödel”, “diagonalisation”).</p><p><strong>Alan Turing</strong> (1912 – 1954) et <strong>Alonzo Church</strong> (1903 – 1995) montrent indépendamment, en 1936, l’indécidabilité de l’Entscheidungsproblem. Turing propose la machine de Turing comme modèle formel de calcul, et Church le lambda-calcul. Ils enoncent le principe selon lequel tout ce qui est calculable peut être calculé sur un de ces deux modèles (“thèse de Church-Turing”).</p><h1 id=définitions>Définitions</h1><h2 id=qu-est-ce-qu-un-problème>Qu&rsquo;est ce qu&rsquo;un problème?</h2><p>Informatiquement, l’appellation problème sera synonyme de fonction. Un problème est caractérisé par:</p><ul><li>Le nom du problème</li><li>des données d&rsquo;entrée, que l&rsquo;on appelle instance du problème.</li><li>une question mathématique posée sur ces données d&rsquo;entrée.</li></ul><p>Rq : Ne pas confondre problème et algorithme le résolvant. Il peut y avoir plusieurs algorithmes qui resolvent le même problème (calculent la même fonction).</p><p>Problème 1<br>Donnée : Un ensemble d&rsquo;entiers naturels<br>Question : Déterminer les nombres pairs de cet ensemble.</p><p>Problème 2<br>Donnée : Un ensemble d&rsquo;entiers naturels<br>Question : Déterminer les nombres premiers de cet ensemble.</p><p>Problème 3<br>Donnée : Un programme C.<br>Question : Le programme est-il syntaxiquement correct ?</p><p>Ce dernier exemple de problème suggère qu&rsquo;un <strong>algorithme</strong> est une
<strong>donnée</strong> comme une autre. En effet, le <strong>script</strong> qui traduit l&rsquo;algorithme est écrit dans un <strong>langage</strong>. Et la machine va le lire et l&rsquo;interpréter à l&rsquo;aide d&rsquo;un autre programme. Pour ce programme, le script est une donnée (<strong>interpréteurs, compilateurs</strong>).</p><h2 id=calculabilité-1>Calculabilité</h2><blockquote><p>Qu’est-ce que c’est “calculable”?</p><ul><li><p>En mathématique : Une fonction f : &#8469;
→ &#8469; est calculable s’il existe un programme/algorithme qui calcule f: si la fonction f est définie sur une entrée x, alors l’algorithme doit renvoyer la valeur f(x), et si f n’est pas définie, l’algorithme doit boucler sur l’entrée x.</p></li><li><p>En algorithmique: on dira qu’une fonction est calculable si elle peut être programmée dans l’un ou l’autre des langages de programmation usuels.</p></li></ul></blockquote><p>La première fonction explicite non calculable a été décrite par Turing en 1936. Il s’agit du problème de l’arrêt : étant donné un algorithme A et une entrée x, il s’agit de déterminer si A s’arrête ou non sur l’entrée x (i.e A ne boucle pas sur l’entrée x).</p><p><strong>Théorème :</strong> Le problème de l’arrêt est incalculable.</p><blockquote><p>Qu&rsquo;est ce que la &ldquo;terminaison&rdquo;? On dit qu’un programme termine s’il ne boucle pas, c’est-à-dire qu’il renvoie bien un résultat.</p></blockquote><h2 id=problèmes-de-décision-décidables>Problèmes de décision décidables</h2><h3 id=problèmes-de-décision>Problèmes de décision</h3><p>Il existe une catégorie de problèmes que l&rsquo;on appelle : <em>problèmes de décision</em>. Dire que le problème est <strong>décidable</strong>, c’est simplement dire qu’il existe un programme Python permettant de calculer f(n) pour tout entier n, en un temps fini.</p><p>Tous les problèmes mathématiques (voir plus haut) peuvent être énoncés comme des problèmes de décision: Pour les problèmes 1 et 2 vus auparavent, on peut les énoncer sous la forme:</p><p>Problème 1<br>Donnée : Un nombre entier positif n en base 2.<br>Question : n est-il pair?</p><p>Problème 2<br>Donnée : Un nombre entier positif n en base 10.<br>Question : n est-il premier?</p><p>Le problème 3 est déjà énoncé comme un problème de décision.</p><p>En conséquence, le problème de la décision, c’est-à-dire la recherche d’une procédure qui indique dans chaque contexte, et au bout d’un temps fini, si une propriété est vraie ou fausse, est équivalent à la construction d’un algorithme qui calcule pour chaque fonction f et pour chaque argument x de f, la valeur y telle que y = f(x). Autrement dit, le problème de la décision est équivalent au problème du calcul.</p><h3 id=décidables-ou-indécidables>décidables ou indécidables?</h3><p>Les fonctions, ou propriétés bien énoncées en langages mathématique sont-elles toutes décidables? La reponse est : Non, il n&rsquo;existe pas de telle méthode, comme cela a été démontré en 1931 par <strong>Kurt Gödel</strong> (voir plus haut).</p><p><strong>L&rsquo;indécidabilité</strong> c&rsquo;est l&rsquo;impossibilité absolue et définitivement démontrée de résoudre par un procédé général de calcul un problème donné.</p><p>Il existe des programmes qui prennent une fonction A comme paramètre, et une donnée x d&rsquo;entrée de cette fonction.</p><p>Si A s’arrête sur l’entrée x, le programme peut renvoyer <code>True</code>. Mais si ce n’est pas le cas, le programme ne répondra jamais. À quel moment décide-t-on qu&rsquo;il n’a pas encore répondu, c’est qu’il ne répondra jamais ? On n’a aucun moyen de le faire, et c’est ce que prouve le théorème de Turing.</p><figure><a href="https://www.youtube.com/watch?v=PsTcL7KlGBg" target=blank><img src=../images/video_decidable.png alt="decidabilité youtube"><figcaption>Décidabilité et indécidabilité : Problème de l'arrêt | Rachid Guerraoui</figcaption></a></figure><blockquote><p>Exemples de problèmes non décidables :</p></blockquote><p>Problème<br>Donnée : Un programme C.<br>Question : Le programme s’arrête-t-il toujours ?</p><h1 id=preuve-d-un-algorithme>Preuve d&rsquo;un algorithme</h1><h2 id=terminaison-et-correction>terminaison et correction</h2><p>Prouver le bon fonctionnement d&rsquo;un algorithme nécessite de vérifier deux propriétés :</p><ol><li>premièrement : la <strong>terminaison</strong> : prouver que l&rsquo;algorithme se termine.</li><li>deuxièmement : la <strong>correction</strong> : si l&rsquo;algorithme se termine, il fait bien ce qu&rsquo;on attend de lui (correction partielle).</li></ol><p>D&rsquo;après ce qui a été vu auparavent, il n&rsquo;EXISTE PAS d&rsquo;algorithme capable de calculer la terminaison ou la correction d&rsquo;un programme. Ce sera à vous de PROUVER un algorithme, à partir de méthodes exposées ici.</p><h2 id=méthodes-pour-les-algorithmes-itératifs>méthodes pour les algorithmes itératifs</h2><blockquote><p>Pour la terminaison : étude du VARIANT de boucle</p><p>Pour la correction : INVARIANT de boucle
<strong>Invariant de boucle :</strong>
on appelle <em>invariant</em> d&rsquo;une itération toute propriété, vraie à l&rsquo;initialisation, et qui demeure conservée quand on passe d&rsquo;un état quelconque à son successeur.</p></blockquote><h2 id=exemple-recherche-linéaire>Exemple : recherche linéaire</h2><h3 id=script>Script</h3><p>La fonction suivante réalise une <em>recherche linéaire</em> de la valeur X sur une liste L de valeurs numériques.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>recherche</span><span style=color:#111>(</span><span style=color:#111>X</span><span style=color:#111>,</span><span style=color:#111>L</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    recherche une valeur dans une liste et renvoie l&#39;indice si la valeur est trouvée, -1 sinon
</span><span style=color:#d88200>    Params :
</span><span style=color:#d88200>    -------------------
</span><span style=color:#d88200>    X : int, valeur à trouver
</span><span style=color:#d88200>    L : list, une liste de valeurs entieres, dans un ordre quelconque.
</span><span style=color:#d88200>    Sortie : 
</span><span style=color:#d88200>    ------
</span><span style=color:#d88200>    j : int, indice de la position de la valeur dans la liste
</span><span style=color:#d88200>    Principe :
</span><span style=color:#d88200>    --------
</span><span style=color:#d88200>    on parcourt la liste avec une boucle non bornée, tant que X n&#39;est pas trouvé dans la liste
</span><span style=color:#d88200>    on augmente la valeur de j à chaque nouvelle itération
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#111>n</span> <span style=color:#f92672>=</span> <span style=color:#111>len</span><span style=color:#111>(</span><span style=color:#111>L</span><span style=color:#111>)</span>
    <span style=color:#00a8c8>while</span> <span style=color:#111>j</span><span style=color:#f92672>&lt;</span><span style=color:#111>n</span> <span style=color:#f92672>and</span> <span style=color:#111>X</span><span style=color:#f92672>!=</span><span style=color:#111>L</span><span style=color:#111>[</span><span style=color:#111>j</span><span style=color:#111>]:</span>
        <span style=color:#111>j</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>j</span><span style=color:#f92672>==</span><span style=color:#111>n</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>j</span></code></pre></div><h3 id=invariant-de-boucle-et-condition-d-arrêt>Invariant de boucle et condition d&rsquo;arrêt</h3><p>L&rsquo;analyse se fait en établissant des <strong>invariants de boucle</strong>, c&rsquo;est à dire des propositions qui sont vraies à chaque itération, et des <strong>conditions d&rsquo;arrêt</strong>.</p><ul><li><p>invariant de boucle : au debut de la première itération, j=0. Et au début de la kieme itération, j=k et L[i]≠X</p></li><li><p>condition d&rsquo;arrêt : si au debut de la kieme itération de la boucle on a : k&lt; n et L[k]=X, alors on s&rsquo;arrête avec j=k; si on a k=n, alors on va s&rsquo;arrêter et on affecte j=-1.</p></li></ul><h2 id=preuve-d-un-algorithme-recursif>Preuve d&rsquo;un algorithme recursif</h2><p>Dans le cas des algorithmes récursifs, ces méthodes sont spécifiques.</p><h3 id=terminaison>terminaison</h3><p>Le (ou l&rsquo;un des) paramètre(s) appelé(s) par la fonction recursive doit avoir une relation d&rsquo;ordre descendante. C&rsquo;est à dire que ce paramètre doit être de plus en plus petit à chaque appel de la fonction dans le corps de la fonction récurente.</p><h3 id=correction-partielle>correction partielle</h3><p>Il faut montrer que si les appels internes à l&rsquo;algorithme font ce qu&rsquo;on attend d&rsquo;eux, alors l&rsquo;algorithme entier fait ce qu&rsquo;on attend de lui. La preuve de correction se fait à partir d&rsquo;une demonstration par recurrence :</p><ul><li>On commence à établir la preuve pour le rang n = 0, puis n = 1.</li><li>il faut montrer que si on peut prouver la correction pour une suite de rang n-1, on aboutira à la preuve de correction pour une suite de rang n.</li></ul><h1 id=résumé>Résumé</h1><p>— L’ensemble des algorithmes, donc des fonctions calculables, est dénombrable.
— L’ensemble des fonctions est indénombrable, donc il existe des fonctions incalculables.
— Le problème de l’arrêt est un exemple de fonction incalculable.</p><h1 id=liens-généralités>Liens : généralités</h1><ul><li>Interstice : <a href=https://interstices.info/alan-turing-du-calculable-a-lindecidable/>décidabilité calculabilité</a></li></ul><h1 id=liens-pour-approfondir>Liens pour approfondir</h1><ul><li>cours en pdf université de Grenoble : <a href=https://www.irif.fr/~asarin//calc2k3/calcul_cours.pdf>calculabilité</a></li><li><a href=http://www.lirmm.fr/%7Egrenet/DIUBloc5/AlgoAvancee.pdf>cours sur l&rsquo;algorithmique Bruno Grenet</a></li><li>cas des algorithmes recursifs : <a href=https://fr.wikipedia.org/wiki/Algorithme_récursif>https://fr.wikipedia.org/wiki/Algorithme_récursif</a></li></ul></article><div style=height:100px></div></div><aside class="book-toc fixed"><nav id=TableOfContents><ul><li><a href=#calculabilité>Calculabilité</a></li><li><a href=#définitions>Définitions</a><ul><li><a href=#qu-est-ce-qu-un-problème>Qu&rsquo;est ce qu&rsquo;un problème?</a></li><li><a href=#calculabilité-1>Calculabilité</a></li><li><a href=#problèmes-de-décision-décidables>Problèmes de décision décidables</a><ul><li><a href=#problèmes-de-décision>Problèmes de décision</a></li><li><a href=#décidables-ou-indécidables>décidables ou indécidables?</a></li></ul></li></ul></li><li><a href=#preuve-d-un-algorithme>Preuve d&rsquo;un algorithme</a><ul><li><a href=#terminaison-et-correction>terminaison et correction</a></li><li><a href=#méthodes-pour-les-algorithmes-itératifs>méthodes pour les algorithmes itératifs</a></li><li><a href=#exemple-recherche-linéaire>Exemple : recherche linéaire</a><ul><li><a href=#script>Script</a></li><li><a href=#invariant-de-boucle-et-condition-d-arrêt>Invariant de boucle et condition d&rsquo;arrêt</a></li></ul></li><li><a href=#preuve-d-un-algorithme-recursif>Preuve d&rsquo;un algorithme recursif</a><ul><li><a href=#terminaison>terminaison</a></li><li><a href=#correction-partielle>correction partielle</a></li></ul></li></ul></li><li><a href=#résumé>Résumé</a></li><li><a href=#liens-généralités>Liens : généralités</a></li><li><a href=#liens-pour-approfondir>Liens pour approfondir</a></li></ul></nav></aside></main><div class=site_footer><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Licence Creative Commons" style=border-width:0 src=/creative.png></a>
<span xmlns:dct=http://purl.org/dc/terms/ property=dct:title>Sciences numeriques</span> de <a xmlns:cc=http://creativecommons.org/ns# href property=cc:attributionName rel=cc:attributionurl>numerix.netlify.com</a> est mis à disposition selon les termes de la <a rel=license href=http://creativecommons.org/licenses/by/4.0/>licence Creative Commons Attribution 4.0 International</a></div></body></html>