<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>recursivité
| Sciences numériques</title><link href="https://fonts.googleapis.com/css?family=Oxygen|Oxygen+Mono:300,400,700" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" rel=stylesheet><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-167114468-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-167114468-1');</script><link rel=stylesheet href=/book.min.f1e2613f7aa93dcefbe9ddabf3c397a9589092437a3504fec4d9a146e5e653dd.css><link rel=icon href=/favicon.png type=image/x-icon><div class=my-header-container><div class=my-site-header><img src=/logo-site-b.svg width="150 px"></div><div id=myHeader><div class=titre><h2><a href=/>Sciences numériques</a></h2></div></div></div><script async>window.onload=function(){let container=document.getElementsByClassName("book-page");let logodiv=document.getElementsByClassName("site-menu-before");let header=document.getElementById("myHeader");let screen=window.innerWidth;let site_footer=document.querySelector(".site_footer");try{let site_TOC=document.querySelector("#TableOfContents>ul");let newP=document.createElement('li');newP.textContent='Contenu de la page';site_TOC.appendChild(newP,null);}
catch(err)
{console.log(err.message);}
if(site_footer.parentNode!=document.body){let father=site_footer.parentNode;let clone=site_footer.cloneNode;father.removeChild(site_footer);document.body.appendChild(clone);}
if(screen<=850){document.getElementsByClassName("my-site-header")[0].style.display="none";}else{window.addEventListener("scroll",function(e){let spectral=document.getElementById("spectral");if(screen>850){if(window.pageYOffset>150){header.classList.add("sticky");if(container.lenght>0){container[0].style.marginTop="65px";};logodiv[0].style.height="120px";}else{header.classList.remove("sticky");if(container.lenght>0){container[0].style.marginTop="0px";};spectral.style.display="none";logodiv[0].style.height="220px";}}
if(screen<=850){if(window.pageYOffset>150){spectral.style.display="block";}else{spectral.style.display="none";}}});}}
let chemin=window.location.pathname;if(chemin.search('NSI')>-1){baniere=document.querySelector("#myHeader");let linkBox=document.createElement('div');linkBox.classList.add('linkBox');let newH=document.createElement('a');newH.innerHTML='<a href="/docs/NSI/NSI_index/index.html">NSI</a>';newH.classList.add('nsi');linkBox.appendChild(newH);baniere.appendChild(linkBox);}</script><style>#myHeader{display:flex;flex-direction:row-reverse}#myHeader>.titre{width:80%;min-width:300px;text-align:left}.linkBox{margin:10px;padding-top:10px;background-color:pink;min-width:50px}.isn{}</style></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav role=navigation><div class=site-menu-before style=height:220px;display:block><img src=/logo-site.svg id=spectral height=50% style=display:none></div><style>nav ul a[href$=\2f docs\2fNSI\2flangages\2fpage2\2f ]{color:#004ed0}</style><ul><li><a href=/><strong>Accueil</strong></a></li><li><a href=/docs/esf/esf_index/><strong>ESF</strong></a></li><li><p><a href=/docs/SNT_2nde/SNT_index/><strong>SNT secondes</strong></a></p></li><li><p><a href=/docs/NSI/NSI_index/><strong>NSI</strong></a></p></li><li><p><a href=/docs/python/index_python/><strong>Python</strong></a></p></li><li><p><a href=/docs/PC_2nde/PC_index/><strong>Physique Chimie 2nde</strong></a></p></li><li><p><a href=/docs/PC_1ere/PC_index/><strong>Physique 1ere Spé</strong></a></p></li><li><p><a href=/posts/><strong>Posts</strong></a></p></li><li><p><a href=/docs/contact/simple-contact-form/><strong>Contact</strong></a></p></li></ul></nav><script>(function(){var menu=document.querySelector('aside.book-menu nav')
addEventListener('beforeunload',function(event){localStorage.setItem('menu.scrollTop',menu.scrollTop)});menu.scrollTop=localStorage.getItem('menu.scrollTop')})()</script></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg alt=Menu></label>
<strong>recursivité</strong></header><article class=markdown><p>Le cours comprend une <a href=../page6/>page d&rsquo;exercices</a> avec un <em>editeur python online</em>.</p><h1 id=récursivité>Récursivité</h1><h2 id=principe>Principe</h2><p>Un algorithme récursif est un algorithme qui fait appel à lui-même dans le corps de sa propre définition. Ce principe est aussi appelé : <em>de l&rsquo;autoréférence</em>.</p><h2 id=analyse-d-un-exemple-itératif-récursif>Analyse d&rsquo;un exemple: itératif =&gt; récursif</h2><p>Considérons une fonction <code>ajoute2_iter</code> qui prend N comme paramètre, et qui ajoute N fois 2.</p><h3 id=algorithme-itératif>Algorithme itératif</h3><p>Supposons que nous souhaitions éviter la multiplication. L&rsquo;algorithme itératif utilisera alors une boucle bornée:</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>ajoute2_iter</span><span style=color:#111>(</span><span style=color:#111>N</span><span style=color:#111>):</span>
  <span style=color:#d88200>&#34;&#34;&#34;ajoute 2 un nombre N de fois
</span><span style=color:#d88200>  &#34;&#34;&#34;</span>
  <span style=color:#111>s</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#111>N</span><span style=color:#111>):</span>
    <span style=color:#111>s</span> <span style=color:#f92672>=</span> <span style=color:#111>s</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>
  <span style=color:#00a8c8>return</span> <span style=color:#111>s</span></code></pre></div><p><em>Résultat</em></p><pre><code>&gt;&gt;&gt; ajoute2_iter(10)
20
</code></pre><h3 id=algorithme-récursif>Algorithme récursif</h3><p>On a la <strong>relation de récurence</strong>:
$$u_{n+1} = 2 + u_n$$</p><p>On va adapter cette relation dans l&rsquo;appel de la fonction:</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>ajoute2</span><span style=color:#111>(</span><span style=color:#111>N</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;fonction qui s&#39;appelle elle-meme N fois
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>N</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span> <span style=color:#111>:</span> 
        <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
        <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#111>ajoute2</span><span style=color:#111>(</span><span style=color:#111>N</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span></code></pre></div><p><em>Résultat</em></p><pre><code>&gt;&gt;&gt; ajoute2(10)
20
</code></pre><h2 id=principe-d-un-algorithme-récursif>Principe d&rsquo;un algorithme récursif</h2><p>L&rsquo;algorithme récursif comprend 2 parties importantes:</p><ul><li>La <strong>Base</strong> : c&rsquo;est le cas pour lequel le problème se resoud immediatement (par exemple <code>if N==0 :
return 0</code> dans le script <code>ajoute2</code>: le problème se resoud immediatement pour N == 0)</li><li><p><strong>L&rsquo;Hérédité</strong> : calcul à partir de paramètres plus &ldquo;petits&rdquo; : <code>return 2 + ajoute2(N-1)</code>.</p><pre><code>def fonction_recursive(param):
if &lt;cas de base&gt; : 
return value
else:
# instructions
fonction_recursive(f(param))
</code></pre></li></ul><p><em>Remarque:</em> Une instruction conditionnelle est incluse dans le corps de la fonction pour forcer la fonction à retourner sans que l’appel de récurrence soit exécuté (La <strong>Base</strong>). Sans cela, le programme pourrait tourner en boucle&hellip;</p><h2 id=comparatif-itératif-récursif>Comparatif itératif - récursif</h2><p>Une grande partie des problèmes peut se résoudre avec une implémentation récursive, comme avec une implémentation itérative. L&rsquo;une ou l&rsquo;autre peut paraître plus ou moins naturelle suivant le problème, ou suivant les habitudes du programmeur.</p><table><thead><tr><th></th><th>Itératif</th><th>Récursif</th></tr></thead><tbody><tr><td>Principe</td><td>Permet d&rsquo;executer plusieurs fois l&rsquo;ensemble des instructions</td><td>La fonction s&rsquo;appelle elle-même</td></tr><tr><td>Format</td><td>L&rsquo;itération comprend l’initialisation, la condition, l’exécution de l’instruction dans une boucle et la mise à jour (incrémenter et décrémenter) la variable de contrôle.</td><td>Seule la condition de terminaison est spécifiée.</td></tr><tr><td>Terminaison</td><td>L’instruction d’itération est exécutée plusieurs fois jusqu’à ce qu’une certaine condition soit atteinte.</td><td>Si la fonction ne converge pas vers une condition appelée (cas de base), elle conduit à une récursion infinie.</td></tr><tr><td>Taille du script</td><td>L&rsquo;itération rend le script plus long</td><td>Taille du script réduite</td></tr></tbody></table><p>Enfin, l&rsquo;algorithme récursif utilise une <em>pile d&rsquo;appels</em>, comme vu sur l&rsquo;animation suivante:</p><figure><img src=https://lyceum.fr/644c0bfaf567173ce9856250e140d861/animation-puiss-recursive.gif alt="animation recursivité puissance"><figcaption>animation issue de la page <a href=https://lyceum.fr/tg/nsi/4-langages-et-programmation/4-recursivite>lyceum - puissance recursive</a></figcaption></figure><p>Il est facile de traiter des suites avec la méthode récursive:</p><ul><li>factorielle</li><li>suite de Fibonacci.</li></ul><h2 id=exemple-factorielle>exemple : factorielle</h2><h3 id=programme-itératif>programme itératif</h3><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fact</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
  <span style=color:#111>res</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#111>):</span>
    <span style=color:#111>res</span><span style=color:#f92672>=</span><span style=color:#111>res</span><span style=color:#f92672>*</span><span style=color:#111>i</span>
  <span style=color:#00a8c8>return</span> <span style=color:#111>res</span> </code></pre></div><div class=preuve><div class=entete>Prouver l'algorithme itératif</div><div class=demo><ol><li>terminaison : l'algorithme consiste en une boucle qui execute n itérations. Le <strong>convergent</strong> n-i decroit strictement à chaque itération et on sort de la boucle quand il vaut 0.</li>Chaque iteration contient un nombre fini d'opérations élémentaires : 1 mutiplication et 1 affectation. Donc il termine après 2n+1 operations.<li>correction (ou validité) :
On prouve par recurrence sur le nombre d'iterations qu'apres la ieme iteration de la boucle for : res=i!</li>Preuve par récurrence : après la 1ere itération, res = 1 ! (OK)<br>Hypothèse de récurrence : (H.R.) supposons qu'après la ieme itération, res=i ! Montrons qu'après la (i+1)ieme iteration, res=(i+1)! :
avant la (i+1)e iteration, res = i !
La (i+1)e iteration multiplie res par i+1, donc après la (i+1)e iteration, $$res= i! \times (i+1) = (i+1)!$$
Après n iterations, res contient n ! donc le resultat est celui attendu.</ol></div></div><h3 id=programme-recursif>Programme recursif</h3><p>On a la <strong>relation de récurence</strong> suivante: $$u<em>{n} = n\times u</em>{n-1}$$</p><p>et $$u_0 = 1$$:</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fact_recur</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
  <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>=</span><span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#111>:</span><span style=color:#00a8c8>return</span> <span style=color:#ae81ff>1</span> <span style=color:#00a8c8>else</span><span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>n</span><span style=color:#f92672>*</span><span style=color:#111>fact_recur</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span></code></pre></div><p>On pourrait représenter la pile d&rsquo;execution de cette fonction de la manière suivante :</p><pre><code>Appel à fact_recur(4)
| 4*fact_recur(3) = ? 
| Appel à fact_recur(3)
| | 3*fact_recur(2) = ? 
| | Appel à fact_recur(2)
| | | 2*fact_recur(1) = ? 
| | | Appel à fact_recur(1)
| | | | 1*fact_recur(0) = ? 
| | | | Appel à fact_recur(0) 
| | | | Retour de la valeur 1
| | | | 1*1
| | | Retour de la valeur 1
| | | 2*1
| | Retour de la valeur 2
| | 3*2
| Retour de la valeur 6
| 4*6
Retour de la valeur 24
</code></pre><div class=preuve><div class=entete>Prouver l'algorithme recursif</div><div class=demo>Dans le cas d'un algo recursif, pas de convergent ni d'invariant de boucle. On prouve par recurrence sur n.<ol><li>Teminaison : si n=0, fact(0) fait un test et renvoie 1, sans appel recursif.</li>Hypothèse de récurrence : fact(n) termine après n appels recursifs. Montrons que fact(n+1) termine après (n+1) appels recursifs.<br>fact(n+1) fait un test n+1>0 donc on passe au `else` puis on appelle fact(n) par recurrence qui termine apres n appels recursifs. Finallement fact(n+1) termine après (n+1) appels recursifs.<li>correction : par recurrence fact(n) = n ! :</li>pour n = 0 : fact(n) = fact(0) = 1 = 0! (OK)<br>si vrai pour n, alors fact(n+1) = (n+1)*fact(n) et par hyp H.R., fact(n) = n! donc (n+1)*n! = (n+1)! (OK)</ol></div></div><h3 id=complexité>Complexité</h3><p>Calcul de la complexité : Soit T(n) le nombre d&rsquo;opérations fondamentales. Pour une fonction récurrente, c&rsquo;est le nombre de résolution de la fonction de récurence.<br>On a T(n) = T(n-1) + 1 donc T(n) = n</p><h1 id=analyser-un-algorithme-récursif>Analyser un algorithme récursif</h1><h2 id=preuve-de-correction-d-un-algorithme-récursif>Preuve de correction d&rsquo;un algorithme récursif</h2><ul><li>terminaison : recherche du convergent</li><li>correction / validité : recherche de l&rsquo;invariant de boucle pour démontrer sa variation selon un argument de recurence</li><li>puis finir en montrant que l&rsquo;invariant de boucle ou bien le resultat obtenu repond bien à la specification de l&rsquo;algorithme</li></ul><h2 id=complexité-d-un-algorithme-recursif>Complexité d&rsquo;un algorithme recursif</h2><p>Pour un algorithme récursif, on compte le nombre d’appel récursif et il suffit en général de se ramener à une relation définissant une suite récurrente. On se ramène souvent à évaluer une relation du type :</p><p>T<sub>n</sub> =a * T<sub>f(n)</sub> + T</p><p>où :</p><ul><li>T<sub>n</sub> est la complexité pour une donnée de taille n ; a est le nombre d’appel récursif ;</li><li>f(n) décrit la variation de n dans l’appel récursif;</li><li>T est la complexité des calculs hors appel récursif.</li></ul><table><thead><tr><th>relation de récurrence sur T</th><th>solution</th><th>comportement asymtotique</th></tr></thead><tbody><tr><td>T(n) = T(n-1) + b</td><td>T(n) = T(0) + b×n (somme de termes constants)</td><td>O(n)</td></tr><tr><td>T(n) = a×T(n-1) + b, a ≠ 1</td><td>T(n) = an × (T(0) – b/(1-a)) + b/(1-a) (suite géométrique)</td><td>O(a<sup>n</sup>)</td></tr><tr><td>T(n) = T(n-1) + a×n + b</td><td>T(n) = T(0) + a×n×(n+1)/2 + n×b (suite arithmetique pour le 2e terme)</td><td>O(n<sup>2</sup>)</td></tr><tr><td>T(n) = T(n/2) + b</td><td>T(n) = T(1) + b×log<sub>2</sub>(n)</td><td>O(log<sub>2</sub>n)</td></tr></tbody></table><h1 id=application-recherche-du-pgcd>Application : recherche du PGCD</h1><h2 id=problème>Problème</h2><p>Etant donné deux entiers naturels n et m, calculer leur pgcd (plus grand commun diviseur)</p><h2 id=algorithme-d-euclide>algorithme d&rsquo;Euclide</h2><p>Euclide propose l’algorithme suivant:</p><ol><li>Calculez le reste r dans la division de a par b</li><li>Si r est nul alors le pgcd est b</li><li>Sinon recommencer l’étape 1 avec a = b et b = r</li></ol><blockquote><p>Exemple d’exécution : a = 32, b = 12 :</p><p>– 32 = (2 x 12) + 8</p><p>– 12 = (1 x 8) + 4</p><p>– 8 = (2 x 4) + 0</p><p>On a donc pgcd(32, 12) = 4</p></blockquote><h2 id=algorithme-pgcd-itératif>Algorithme PGCD itératif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>euclide</span><span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    a et b sont des entiers, a &gt; b
</span><span style=color:#d88200>    euclide retourne un entier qui est le PGCD de a et b
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>x</span><span style=color:#f92672>=</span><span style=color:#111>a</span>
    <span style=color:#111>y</span><span style=color:#f92672>=</span><span style=color:#111>b</span>
    <span style=color:#00a8c8>while</span> <span style=color:#111>y</span><span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span> <span style=color:#111>:</span>
        <span style=color:#111>temp</span><span style=color:#f92672>=</span><span style=color:#111>y</span>
        <span style=color:#111>y</span><span style=color:#f92672>=</span><span style=color:#111>x</span><span style=color:#f92672>%</span><span style=color:#111>y</span>
        <span style=color:#111>x</span><span style=color:#f92672>=</span><span style=color:#111>temp</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>x</span></code></pre></div><div class=preuve><div class=entete>Prouver l'algorithme itératif</div><div class=demo><ol><li>Terminaison : on utilise une boucle non bornée avec y qui est le convergent. On affecte à y le reste de la division par y (c'est donc inferieur à y). y décroit ainsi jusqu'à 0, ce qui est la condition de fin de la boucle.</li><li>Correction : Tout diviseur commun de a et b divise aussi r = a - bq, et réciproquement tout diviseur commun de b et r divise aussi a = bq + r. Donc le calcul du PGCD de a et b se ramène à celui du PGCD de b et r.<br>l'invariant de boucle, c'est donc :<br>euclide(a,b) = euclide(b, a modulo b)<br>C'est ce qui est réalisé par la fonction, puisque l'on a comme valeurs pour les couples (x,y) successivement :<br>(a,b)<br>(b, a mod b)<br>(a mod b, (a mod b) mod (a mod b))...<br>(* , 0)<br></li></ol></div></div><h2 id=algorithme-recursif>algorithme recursif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>PGCD</span><span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>):</span>
  <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>  PGCD : entier correspondant au plus grand diviseur commun de a par b
</span><span style=color:#d88200>  a et b : entiers tels que a &gt; b
</span><span style=color:#d88200>  &#34;&#34;&#34;</span>
  <span style=color:#00a8c8>if</span> <span style=color:#111>b</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>a</span>
  <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
    <span style=color:#111>c</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span> <span style=color:#f92672>%</span> <span style=color:#111>b</span><span style=color:#111>;</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>PGCD</span><span style=color:#111>(</span><span style=color:#111>b</span><span style=color:#111>,</span><span style=color:#111>c</span><span style=color:#111>)</span></code></pre></div><h1 id=application-suite-de-fibonacci>Application : suite de Fibonacci</h1><h2 id=définitions>Définitions</h2><p>Fibonacci était le surnom de Léonard de Pise ( 1170 -1250) . Il a posé un problème dans lequel il cherche à calculer le nombre de couples de lapins au bout de n années, lorsqu’ils se reproduisent selon les règles suivantes :</p><ul><li>Lors de la première année, l&rsquo;éleveur démarre avec un couple de lapins nouveaux nés.</li><li>Un couple de lapins donne naissance à un nouveau couple tous les ans, à partir de la 2ème année (la 1ère année, il est trop jeune).</li></ul><p>On peut compléter le tableau suivant présentant l&rsquo;effectif de ces couples de lapins :</p><table><thead><tr><th>numero de l&rsquo;année</th><th>nombre de couples de l&rsquo;année précédente</th><th>nouveau nombre de couples</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>1 + 0</td></tr><tr><td>3</td><td>1</td><td>1 + 1</td></tr><tr><td>4</td><td>2</td><td>2 + 1</td></tr><tr><td>5</td><td>3</td><td>3 + 2</td></tr><tr><td>6</td><td>&hellip;</td><td>&hellip;</td></tr></tbody></table><p>On définit la suite (f<sub>n</sub>) des nombres de Fibonacci par :
$$\left\{\begin{matrix}\begin{align}f_0 &amp; =0\\f_1 &amp; =1\\f_{n+1} &amp; =f_{n}+f_{n-1}, \forall n \in \mathbb{N}^+\end{align}\end{matrix}\right.$$</p><p>Les nombres de Fibonacci apparaissent aussi dans la croissance des plantes. Le nombre de pétales des différentes fleurs est souvent un nombre de la suite de Fibonacci. On remarque que l’ angle entre deux primordia successifs, tend vers L’ANGLE D’OR, et que plus les nombres successifs sont grands, plus le rapport s’approche du NOMBRE D’OR.</p><h2 id=algorithme-itératif-1>Algorithme itératif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fibonacci</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>)</span> <span style=color:#111>:</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    fonction qui prend en paramètre n, entier sup ou egal à O.
</span><span style=color:#d88200>    cette fonction utilise une variable f de type tableau.
</span><span style=color:#d88200>    A la fin, cette fonction retourne f[n], le terme de rang n du 
</span><span style=color:#d88200>    tableau f qui contient les éléments entiers calculés selon l&#39;algorithme 
</span><span style=color:#d88200>    de fibonacci où l&#39;élement de rang i est la somme des elements i-1 et i-2.
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>f</span> <span style=color:#f92672>=</span> <span style=color:#111>[]</span>
    <span style=color:#111>f</span><span style=color:#f92672>.</span><span style=color:#111>append</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>)</span>
    <span style=color:#111>f</span><span style=color:#f92672>.</span><span style=color:#111>append</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>n</span><span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span><span style=color:#111>:</span><span style=color:#00a8c8>return</span> <span style=color:#111>f</span><span style=color:#111>[</span><span style=color:#111>n</span><span style=color:#111>]</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span> <span style=color:#111>(</span><span style=color:#ae81ff>2</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#111>):</span> 
        <span style=color:#111>f</span><span style=color:#f92672>.</span><span style=color:#111>append</span><span style=color:#111>(</span><span style=color:#111>f</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>]</span> <span style=color:#f92672>+</span> <span style=color:#111>f</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#111>])</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>f</span><span style=color:#111>[</span><span style=color:#111>n</span><span style=color:#111>]</span></code></pre></div><p><em>Exercice :</em> Ecrire un programme qui permet d&rsquo;afficher tous les nombres de la suite de Fibonacci, du rang 0 au rang n=10.</p><h2 id=algorithme-récursif-1>Algorithme récursif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fibo</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    algo recursif
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>==</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>fibonacci</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span> <span style=color:#f92672>+</span> <span style=color:#111>fibonacci</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#111>)</span></code></pre></div><div class=preuve><div class=entete>Complexité</div><div class=demo>On prouve par récurrence que le cas le pire (c'est à dire celui où le nombre d'itérations à exécuter est le plus grand), est celui où a et b sont des termes consécutifs de la <strong>suite de Fibonacci</strong>. Cela revient à montrer que deux termes successifs de la suite de Fibonacci sont premiers entre eux.
(si leur plus grand diviseur commun est 1)<ul><li>La propriété est vraie pour n = 1 : f<sub>2</sub> et f<sub>1</sub> sont premiers entre eux.</li><li>Supposons que f<sub>n</sub> et f<sub>n-1</sub> soient premiers entre eux :<br>Soit d le PGCD de fn et fn+1, alors d divise f<sub>n+1</sub>– f<sub>n</sub>.<br>d est à la fois diviseur de f<sub>n+1</sub> et f<sub>n</sub><br>Or : (suite de Fibonacci)<br>$$f_{n+1} = f_n + f_{n-1}$$
Donc :
$$f_{n-1} = f_{n+1} - f_n$$
Il faut alors que f<sub>n-1</sub>, f<sub>n+1</sub> et f<sub>n</sub> aient un même diviseur, d. Or le diviseur commun de f<sub>n-1</sub> et f<sub>n</sub> est 1, donc d = 1.</li></ul>Dans ce <strong>pire</strong> cas, la complexité de l'algorithme est alors O(log<sub>10</sub> b). C'est proportionnel au nombre de divisions euclidiennes réalisées.</div></div><p>Parfois, l&rsquo;algorithme récursif n&rsquo;est pas le plus performant: Pour l&rsquo;exemple de la suite de Fibonacci, on constate que les mêmes calculs sont répétés plusieurs fois, comme fibo(2) dans le cas présent pour N = 4):</p><figure><img src=../images/page2/fibo.png><figcaption>pile d'appels pour la suite de fibonacci recursive</figcaption></figure><p>Mais la récursivité intervient aussi dans de nombreux problèmes où elle s’impose comme la méthode la plus adaptée, pour ne pas dire la seule. Un exemple historique est celui des tours de Hanoi. Un jeu inventé par Edouard Lucas, vers 1880. Son traitement sur ordinateur a fait sensation, grâce à la simplicité de son script récursif&hellip;</p><h1 id=application-les-tours-de-hanoï>Application : les tours de Hanoï</h1><h2 id=principe-1>Principe</h2><p>On considère trois tiges plantées dans une base. Au départ, sur la première tige sont enfilées N disques de plus en plus étroits. Le but du jeu est de transférer les N disques sur la troisième tige en conservant la configuration initiale.</p><p><strong>On ne peut déplacer qu&rsquo;un seul disque à la fois et il est interdit de poser un disque sur un autre plus petit.</strong></p><p>il faut à un moment ou à un autre faire la place pour pouvoir déplacer le gros disque du dessous, ce qui impose d’avoir déplacé préalablement les N–1 plus petits sur un seul et même piquet, c’est-à-dire, d’avoir résolu préalablement le problème des tours de Hanoï pour ces N–1 disques :</p><p>Le problème initial (déplacer N disques de A à C en utilisant B) devient donc &ldquo;déplacer N-1 disques de A à B, déplacer le Nème disque de A à C, puis déplacer les N-1 disques de B à C&rdquo;. Dans les deux déplacements de N-1 disques, on dispose d&rsquo;un troisième pilier dont on peut se servir&hellip;</p><p><a href=http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/><figure><img src=../images/page2/hanoi.png alt="algorithme des tours de Hanoï" width=80%><figcaption>image issue du site :<br><a href=http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/>http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/</a></figcaption></figure></a></p><h2 id=algorithme-récursif-2>algorithme récursif</h2><p>L&rsquo;algorithme récursif pour ce problème est étonnament réduit :</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>hanoi</span><span style=color:#111>(</span><span style=color:#111>N</span><span style=color:#111>,</span><span style=color:#111>d</span><span style=color:#111>,</span><span style=color:#111>i</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;N disques doivent être déplacés de d vers a
</span><span style=color:#d88200>    Params:
</span><span style=color:#d88200>    N : int
</span><span style=color:#d88200>        nombre de disques
</span><span style=color:#d88200>    d: int
</span><span style=color:#d88200>        depart (vaut 1 au debut)
</span><span style=color:#d88200>    i: int
</span><span style=color:#d88200>        intermediaire (vaut 2 au debut)
</span><span style=color:#d88200>    a: int
</span><span style=color:#d88200>        fin (vaut 3 au debut)
</span><span style=color:#d88200>    Exemple:
</span><span style=color:#d88200>    lancer avec 
</span><span style=color:#d88200>    &gt;&gt;&gt; hanoi(3,1,2,3)
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>N</span><span style=color:#f92672>==</span><span style=color:#ae81ff>1</span> <span style=color:#111>:</span> 
        <span style=color:#00a8c8>print</span><span style=color:#111>(</span><span style=color:#d88200>&#39;deplacement de {} vers {}&#39;</span><span style=color:#f92672>.</span><span style=color:#111>format</span><span style=color:#111>(</span><span style=color:#111>d</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>))</span>
    <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
        <span style=color:#111>hanoi</span><span style=color:#111>(</span><span style=color:#111>N</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>d</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>i</span><span style=color:#111>)</span>
        <span style=color:#111>hanoi</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>d</span><span style=color:#111>,</span><span style=color:#111>i</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>)</span>
        <span style=color:#111>hanoi</span><span style=color:#111>(</span><span style=color:#111>N</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>i</span><span style=color:#111>,</span><span style=color:#111>d</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>)</span></code></pre></div><p><em>Résultat</em></p><pre><code>&gt;&gt;&gt; hanoi(3,1,2,3)
deplacement de 1 vers 3
deplacement de 1 vers 2
deplacement de 3 vers 2
deplacement de 1 vers 3
deplacement de 2 vers 1
deplacement de 2 vers 3
deplacement de 1 vers 3
</code></pre><h1 id=d-autres-domaines-exploitant-la-récursivité>D&rsquo;autres domaines exploitant la récursivité</h1><p>La récursivité se retrouvent dans d&rsquo;autres situations, où elle prend parfois d&rsquo;autres noms.</p><p>L&rsquo;<strong>autosimilarité</strong> est le caractère d&rsquo;un objet dans laquelle on peut trouver des similarités en l&rsquo;observant à différentes échelles.
<em>Exemple :</em> le Tapis de Sierpiński.</p><figure><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Sierpinski_carpet_6%2C_white_on_black.svg/440px-Sierpinski_carpet_6%2C_white_on_black.svg.png width=300px alt="le Tapis de Sierpiński"><figcaption>le Tapis de Sierpiński et l'autosimilarité</figcaption></figure><p>Les <strong>fractales</strong> ont cette propriété d&rsquo;autosimilarité, mais elles ont plutôt à voir avec un phénomène un peu différent qui s&rsquo;appel la corécurisivité (ou corécursion). Le tapis de Sierpiński, du nom de Wacław Sierpiński, est une fractale obtenue à partir d&rsquo;un carré. Le tapis se fabrique en découpant le carré en neuf carrés égaux avec une grille de trois par trois, et en supprimant la pièce centrale, et en appliquant cette procédure récursivement aux huit carrés restants.</p><p>La <strong>mise en abyme</strong> est un procédé consistant à représenter une œuvre dans une œuvre similaire, par exemple en incrustant dans une image cette image elle-même.</p><p><em>Approfondir :</em> voir la page <a href=https://fr.wikipedia.org/wiki/Algorithme_récursif>https://fr.wikipedia.org/wiki/Algorithme_récursif</a></p><h1 id=exercices>Exercices</h1><h2 id=ex-1-longueur-d-une-liste>Ex 1 : longueur d&rsquo;une liste</h2><h3 id=algorithme-intératif>algorithme intératif :</h3><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>len_iterative</span><span style=color:#111>(</span><span style=color:#111>seq</span><span style=color:#111>):</span> 
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    Return the length of a list (iterative) 
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>count</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>elt</span> <span style=color:#f92672>in</span> <span style=color:#111>seq</span><span style=color:#111>:</span>
        <span style=color:#111>count</span> <span style=color:#f92672>=</span> <span style=color:#111>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> 
    <span style=color:#00a8c8>return</span> <span style=color:#111>count</span></code></pre></div><h4 id=1-réaliser-la-preuve-de-cet-algorithme>1. réaliser la preuve de cet algorithme.</h4><h3 id=algorithme-récursif-3>algorithme récursif</h3><h4 id=2-ecrire-le-script-python-de-l-algorithme-récursif>2. Ecrire le script python de l&rsquo;algorithme récursif</h4><p><em>Aide pour l&rsquo;écriture de l&rsquo;algorithme recursif :</em> la fonction récursive s&rsquo;appelera <code>len_recursive</code>, et aura aussi pour argument <code>seq</code>. Si on veut passer en argument la liste <code>seq</code> de laquelle on retire le premier élément, on fait : <code>len_recursive(seq[1:])</code>. Il faudra alors s&rsquo;inspirer de la relation de récurence suivante : $$u_{n+1} = 1 + u_n$$ lors de l&rsquo;appel recursif.</p><h2 id=ex-2-exponentiation>Ex 2 : Exponentiation</h2><p>Etudions l&rsquo;exponentiation à travers deux exemples.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>exp1</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>)</span> <span style=color:#111>:</span> 
  <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>  programme qui donne x^n en sortie sans utiliser **
</span><span style=color:#d88200>  n : entier
</span><span style=color:#d88200>  x : reel
</span><span style=color:#d88200>  exp1 : reel
</span><span style=color:#d88200>  &#34;&#34;&#34;</span>
  <span style=color:#111>acc</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#111>):</span>
    <span style=color:#111>acc</span><span style=color:#f92672>*=</span><span style=color:#111>x</span>
  <span style=color:#00a8c8>return</span> <span style=color:#111>acc</span>

<span style=color:#00a8c8>def</span> <span style=color:#75af00>exp2</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    n : entier
</span><span style=color:#d88200>    x : reel
</span><span style=color:#d88200>    exp1 : reel
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>n</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>else</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>exp2</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>)</span><span style=color:#f92672>*</span><span style=color:#111>x</span></code></pre></div><ol><li>Combien de produits sont necessaires pour calculer une puissance n-ième avec la fonction <code>exp1</code> ?</li><li>Pour la fonction <code>exp2</code> : Soit u<sub>n</sub> le nombre de produits nécessaires pour calculer une puissance n-ième. Quelle est la relation de récurrence vérifiée par u<sub>n+1</sub> ? $$u_{n+1} = u_n + &hellip;$$</li><li>En déduire la complexité pour ces 2 fonctions.</li></ol><h1 id=autres-exercices-avec-editeur-online>Autres exercices avec editeur online</h1><p><a href=../page6/>Lien vers la page des exercices</a></p><h1 id=liens>Liens</h1><ul><li>article sur les tours de Hanoi <a href=http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/>http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/</a></li><li>algorithmes recursifs : <a href=https://fr.wikipedia.org/wiki/Algorithme_récursif>https://fr.wikipedia.org/wiki/Algorithme_récursif</a></li></ul></article><div style=height:100px></div></div><aside class="book-toc fixed"><nav id=TableOfContents><ul><li><a href=#récursivité>Récursivité</a><ul><li><a href=#principe>Principe</a></li><li><a href=#analyse-d-un-exemple-itératif-récursif>Analyse d&rsquo;un exemple: itératif =&gt; récursif</a><ul><li><a href=#algorithme-itératif>Algorithme itératif</a></li><li><a href=#algorithme-récursif>Algorithme récursif</a></li></ul></li><li><a href=#principe-d-un-algorithme-récursif>Principe d&rsquo;un algorithme récursif</a></li><li><a href=#comparatif-itératif-récursif>Comparatif itératif - récursif</a></li><li><a href=#exemple-factorielle>exemple : factorielle</a><ul><li><a href=#programme-itératif>programme itératif</a></li><li><a href=#programme-recursif>Programme recursif</a></li><li><a href=#complexité>Complexité</a></li></ul></li></ul></li><li><a href=#analyser-un-algorithme-récursif>Analyser un algorithme récursif</a><ul><li><a href=#preuve-de-correction-d-un-algorithme-récursif>Preuve de correction d&rsquo;un algorithme récursif</a></li><li><a href=#complexité-d-un-algorithme-recursif>Complexité d&rsquo;un algorithme recursif</a></li></ul></li><li><a href=#application-recherche-du-pgcd>Application : recherche du PGCD</a><ul><li><a href=#problème>Problème</a></li><li><a href=#algorithme-d-euclide>algorithme d&rsquo;Euclide</a></li><li><a href=#algorithme-pgcd-itératif>Algorithme PGCD itératif</a></li><li><a href=#algorithme-recursif>algorithme recursif</a></li></ul></li><li><a href=#application-suite-de-fibonacci>Application : suite de Fibonacci</a><ul><li><a href=#définitions>Définitions</a></li><li><a href=#algorithme-itératif-1>Algorithme itératif</a></li><li><a href=#algorithme-récursif-1>Algorithme récursif</a></li></ul></li><li><a href=#application-les-tours-de-hanoï>Application : les tours de Hanoï</a><ul><li><a href=#principe-1>Principe</a></li><li><a href=#algorithme-récursif-2>algorithme récursif</a></li></ul></li><li><a href=#d-autres-domaines-exploitant-la-récursivité>D&rsquo;autres domaines exploitant la récursivité</a></li><li><a href=#exercices>Exercices</a><ul><li><a href=#ex-1-longueur-d-une-liste>Ex 1 : longueur d&rsquo;une liste</a><ul><li><a href=#algorithme-intératif>algorithme intératif :</a><ul><li><a href=#1-réaliser-la-preuve-de-cet-algorithme>1. réaliser la preuve de cet algorithme.</a></li></ul></li><li><a href=#algorithme-récursif-3>algorithme récursif</a><ul><li><a href=#2-ecrire-le-script-python-de-l-algorithme-récursif>2. Ecrire le script python de l&rsquo;algorithme récursif</a></li></ul></li></ul></li><li><a href=#ex-2-exponentiation>Ex 2 : Exponentiation</a></li></ul></li><li><a href=#autres-exercices-avec-editeur-online>Autres exercices avec editeur online</a></li><li><a href=#liens>Liens</a></li></ul></nav></aside></main><div class=site_footer><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Licence Creative Commons" style=border-width:0 src=/creative.png></a>
<span xmlns:dct=http://purl.org/dc/terms/ property=dct:title>Sciences numeriques</span> de <a xmlns:cc=http://creativecommons.org/ns# href property=cc:attributionName rel=cc:attributionurl>numerix.netlify.com</a> est mis à disposition selon les termes de la <a rel=license href=http://creativecommons.org/licenses/by/4.0/>licence Creative Commons Attribution 4.0 International</a></div></body></html>