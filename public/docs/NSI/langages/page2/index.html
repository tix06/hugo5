<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>recursivité
| Sciences numériques</title><link href="https://fonts.googleapis.com/css?family=Oxygen|Oxygen+Mono:300,400,700" rel=stylesheet><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-167114468-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-167114468-1');</script><link rel=stylesheet href=/book.min.7c12242b16bb04d5498077bb2f2651d056db8ac8ff68b2b9754bdd293811e401.css><link rel=icon href=/favicon.png type=image/x-icon><div class=my-header-container><div class=my-site-header><img src=/logo-site-b.svg width="150 px"></div><div id=myHeader><div class=titre><h2><a href=/>Sciences numériques</a></h2></div></div></div><script async>window.onload=function(){let container=document.getElementsByClassName("book-page");let logodiv=document.getElementsByClassName("site-menu-before");let header=document.getElementById("myHeader");let screen=window.innerWidth;let site_footer=document.querySelector(".site_footer");try{let site_TOC=document.querySelector("#TableOfContents>ul");let newP=document.createElement('li');newP.textContent='Contenu de la page';site_TOC.appendChild(newP,null);}
catch(err)
{console.log(err.message);}
if(site_footer.parentNode!=document.body){let father=site_footer.parentNode;let clone=site_footer.cloneNode;father.removeChild(site_footer);document.body.appendChild(clone);}
if(screen<=850){document.getElementsByClassName("my-site-header")[0].style.display="none";}else{window.addEventListener("scroll",function(e){let spectral=document.getElementById("spectral");if(screen>850){if(window.pageYOffset>150){header.classList.add("sticky");if(container.lenght>0){container[0].style.marginTop="65px";};logodiv[0].style.height="120px";}else{header.classList.remove("sticky");if(container.lenght>0){container[0].style.marginTop="0px";};spectral.style.display="none";logodiv[0].style.height="220px";}}
if(screen<=850){if(window.pageYOffset>150){spectral.style.display="block";}else{spectral.style.display="none";}}});}}</script></head><body><input type=checkbox style=display:none id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav role=navigation><div class=site-menu-before style=height:220px;display:block><img src=/logo-site.svg id=spectral height=50% style=display:none></div><style>nav ul a[href$=\2f docs\2fNSI\2flangages\2fpage2\2f ]{color:#004ed0}</style><ul><li><a href=/><strong>Accueil</strong></a></li><li><a href=/docs/esf/esf_index/><strong>ESF</strong></a></li><li><p><a href=/docs/SNT_2nde/SNT_index/><strong>SNT secondes</strong></a></p></li><li><p><a href=/docs/NSI/NSI_index/><strong>NSI</strong></a></p><ul><li><a href=/docs/NSI/NSI_architecture/>architecture informatique</a></li><li><a href=/docs/NSI/NSI_structure/>structure de données</a></li><li><a href=/docs/NSI/NSI_bases/>bases de données</a></li><li><a href=/docs/NSI/NSI_langages/>langages</a></li><li><a href=/docs/NSI/NSI_algorithmes/>algorithmes</a><br></li></ul></li><li><p><a href=/docs/python/index_python/><strong>Python</strong></a></p></li><li><p><a href=/docs/PC_2nde/PC_index/><strong>Physique Chimie 2nde</strong></a></p><ul><li><a href=/docs/PC_2nde/physique/pages/page1/>physique du mouvement</a></li><li><a href=/docs/PC_2nde/physique/pages/page2/>échanges thermiques</a></li><li><a href=/docs/PC_2nde/chimie/pages/mole/>la mole</a></li><li><a href=/docs/PC_2nde/chimie/pages/transformation/>transformation chimique</a></li><li><a href=/docs/PC_2nde/chimie/pages/avancement/>animation avancement</a></li></ul></li><li><p><a href=/docs/PC_1ere/PC_index/><strong>Physique 1ere Spé</strong></a></p><ul><li><a href=/docs/PC_1ere/energie/energie1/>Energie</a></li><li><a href=/docs/PC_1ere/atome/atome/>modèle de Bohr de l&rsquo;atome</a></li><li><a href=/docs/PC_1ere/notebooks/PC_notebooks/>ipython notebooks</a></li></ul></li><li><p><a href=/posts/><strong>Posts</strong></a></p></li><li><p><a href=/docs/contact/simple-contact-form/><strong>Contact</strong></a></p></li></ul></nav><script>(function(){var menu=document.querySelector('aside.book-menu nav')
addEventListener('beforeunload',function(event){localStorage.setItem('menu.scrollTop',menu.scrollTop)});menu.scrollTop=localStorage.getItem('menu.scrollTop')})()</script></aside><div class=book-page><header class="align-center justify-between book-header"><label for=menu-control><img src=/svg/menu.svg alt=Menu></label>
<strong>recursivité</strong></header><article class=markdown><h1 id=récursivité>Récursivité</h1><h2 id=principe>Principe</h2><p>Un algorithme récursif est un algorithme qui fait appel à lui-même dans le corps de sa propre définition. Ce principe est aussi appelé : <em>de l&rsquo;autoréférence</em>.</p><p>Les questions à se poser pour élaborer l&rsquo;algorithme :</p><ul><li>Est-ce que le problème dépend d’un (ou plusieurs) paramètre(s) ?</li><li>Est-il possible de résoudre le problème lorsque la (les) valeur(s) du paramètre est &ldquo;petite(s)&rdquo; ?</li><li>Est-il possible de résoudre le problème à l’aide de la résolution du problème portant sur une (des) &ldquo;plus petite(s)&rdquo; valeur(s) du paramètre ?</li></ul><p>Définir alors :</p><ul><li>La <strong>Base</strong> : où on s’arrête, pas d’appel récursif (par exemple <code>if b = 0 then return a</code> dans l&rsquo;algo PGCD)</li><li><strong>L&rsquo;Hérédité</strong> : calcul à partir de paramètres plus &ldquo;petits&rdquo;</li></ul><p>Une grande partie des problèmes peut se résoudre avec une implémentation récursive, comme avec une implémentation itérative. L&rsquo;une ou l&rsquo;autre peut paraître plus ou moins naturelle suivant le problème, ou suivant les habitudes du programmeur.</p><h2 id=complexité-d-un-algorithme-recursif>Complexité d&rsquo;un algorithme recursif</h2><p>Pour un algorithme récursif, on compte le nombre d’appel récursif et il suffit en général de se ramener à une relation définissant une suite récurrente. On se ramène souvent à évaluer une relation du type :</p><p>$$C<em>n =a\times C</em>{f(n)} + C$$</p><p>où :</p><ul><li>C<sub>n</sub> est la complexité pour une donnée de taille n ; o a est le nombre d’appel récursif ;</li><li>f(n) décrit la variation de n dans l’appel récursif;</li><li>C est la complexité des calculs hors appel récursif.</li></ul><table><thead><tr><th>relation de récurrence</th><th>solution</th><th>comportement asymtotique</th></tr></thead><tbody><tr><td>C(n) = C(n-1) + b</td><td>C(n) = C(0) + b×n (suite arithmétique)</td><td>O(a<sup>n</sup>)</td></tr><tr><td>C(n) = a×C(n-1) + b, a ≠ 1</td><td>C(n) = an × (C(0) – b/(1-a)) + b/(1-a) (suite géométrique)</td><td>O(a<sup>n</sup>)</td></tr><tr><td>C(n) = C(n-1) + a×n + b</td><td>C(n) = C(0) + a×n×(n+1)/2 + n×b</td><td>O(n<sup>2</sup>)</td></tr><tr><td>C(n) = C(n/2) + b</td><td>C(n) = C(1) + b×log<sub>2</sub>(n)</td><td>O(log<sub>2</sub>n)</td></tr></tbody></table><h2 id=exemple-factorielle>exemple : factorielle</h2><h3 id=programme-itératif>programme itératif</h3><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fact</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
  <span style=color:#111>res</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#111>):</span>
    <span style=color:#111>res</span><span style=color:#f92672>=</span><span style=color:#111>res</span><span style=color:#f92672>*</span><span style=color:#111>i</span>
  <span style=color:#00a8c8>return</span> <span style=color:#111>res</span> </code></pre></div><div class=preuve><div class=entete>Prouver l'algorithme itératif</div><div class=demo><ol><li>terminaison : l'algorithme consiste en une boucle qui execute n itérations. Le <strong>convergent</strong> n-i decroit strictement à chaque itération et on sort de la boucle quand il vaut 0.</li>Chaque iteration contient un nombre fini d'opérations élémentaires : 1 mutiplication et 1 affectation. Donc il termine après 2n+1 operations.<li>correction (ou validité) :
On prouve par recurrence sur le nombre d'iterations qu'apres la ieme iteration de la boucle for : res=i!</li>Preuve par récurrence : après la 1ere itération, res = 1 ! (OK)<br>Hypothèse de récurrence : (H.R.) supposons qu'après la ieme itération, res=i ! Montrons qu'après la (i+1)ieme iteration, res=(i+1)! :
avant la (i+1)e iteration, res = i !
La (i+1)e iteration multiplie res par i+1, donc après la (i+1)e iteration, $$res= i! \times (i+1) = (i+1)!$$
Après n iterations, res contient n ! donc le resultat est celui attendu.</ol></div></div><h3 id=programme-recursif>Programme recursif</h3><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fact_recur</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
  <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>=</span><span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#111>:</span><span style=color:#00a8c8>return</span> <span style=color:#ae81ff>1</span> <span style=color:#00a8c8>else</span><span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>n</span><span style=color:#f92672>*</span><span style=color:#111>fact_recur</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span></code></pre></div><p>On pourrait représenter la pile d&rsquo;execution de cette fonction de la manière suivante :</p><pre><code>Appel à fact_recur(4)
| 4*fact_recur(3) = ? 
| Appel à fact_recur(3)
| | 3*fact_recur(2) = ? 
| | Appel à fact_recur(2)
| | | 2*fact_recur(1) = ? 
| | | Appel à fact_recur(1)
| | | | 1*fact_recur(0) = ? 
| | | | Appel à fact_recur(0) 
| | | | Retour de la valeur 1
| | | | 1*1
| | | Retour de la valeur 1
| | | 2*1
| | Retour de la valeur 2
| | 3*2
| Retour de la valeur 6
| 4*6
Retour de la valeur 24
</code></pre><div class=preuve><div class=entete>Prouver l'algorithme recursif</div><div class=demo>Dans le cas d'un algo recursif, pas de convergent ni d'invariant de boucle. On prouve par recurrence sur n.<ol><li>Teminaison : si n=0, fact(0) fait un test et renvoie 1, sans appel recursif.</li>Hypothèse de récurrence : fact(n) termine après n appels recursifs. Montrons que fact(n+1) termine après (n+1) appels recursifs.<br>fact(n+1) fait un test n+1>0 donc on passe au `else` puis on appelle fact(n) par recurrence qui termine apres n appels recursifs. Finallement fact(n+1) termine après (n+1) appels recursifs.<li>correction : par recurrence fact(n) = n ! :</li>pour n = 0 : fact(n) = fact(0) = 1 = 0! (OK)<br>si vrai pour n, alors fact(n+1) = (n+1)*fact(n) et par hyp H.R., fact(n) = n! donc (n+1)*n! = (n+1)! (OK)</ol></div></div><h3 id=complexité>Complexité</h3><p>Calcul de la complexité : Soit T(n) le nombre d&rsquo;opérations fondamentales. Pour une fonction récurrente, c&rsquo;est le nombre de résolution de la fonction de récurence.<br>On a T(n) = T(n-1) + 1 donc T(n) = n</p><h1 id=preuve-de-correction-d-un-algorithme-récursif>Preuve de correction d&rsquo;un algorithme récursif</h1><ul><li>terminaison : recherche du convergent</li><li>correction / validité : recherche de l&rsquo;invariant de boucle pour démontrer sa variation selon un argument de recurence</li><li>puis finir en montrant que l&rsquo;invariant de boucle ou bien le resultat obtenu repond bien à la specification de l&rsquo;algorithme</li></ul><h1 id=application-recherche-du-pgcd>Application : recherche du PGCD</h1><h2 id=problème>Problème</h2><p>Etant donné deux entiers naturels n et m, calculer leur pgcd (plus grand commun diviseur)</p><h2 id=algorithme-d-euclide>algorithme d&rsquo;Euclide</h2><p>Euclide propose l’algorithme suivant:</p><ol><li>Calculez le reste r dans la division de a par b</li><li>Si r est nul alors le pgcd est b</li><li>Sinon recommencer l’étape 1 avec a = b et b = r</li></ol><blockquote><p>Exemple d’exécution : a = 32, b = 12 :</p><p>– 32 = (2 x 12) + 8</p><p>– 12 = (1 x 8) + 4</p><p>– 8 = (2 x 4) + 0</p><p>On a donc pgcd(32, 12) = 4</p></blockquote><h2 id=algorithme-pgcd-itératif>Algorithme PGCD itératif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>euclide</span><span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    a et b sont des entiers, a &gt; b
</span><span style=color:#d88200>    euclide retourne un entier qui est le PGCD de a et b
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>x</span><span style=color:#f92672>=</span><span style=color:#111>a</span>
    <span style=color:#111>y</span><span style=color:#f92672>=</span><span style=color:#111>b</span>
    <span style=color:#00a8c8>while</span> <span style=color:#111>y</span><span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span> <span style=color:#111>:</span>
        <span style=color:#111>temp</span><span style=color:#f92672>=</span><span style=color:#111>y</span>
        <span style=color:#111>y</span><span style=color:#f92672>=</span><span style=color:#111>x</span><span style=color:#f92672>%</span><span style=color:#111>y</span>
        <span style=color:#111>x</span><span style=color:#f92672>=</span><span style=color:#111>temp</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>x</span></code></pre></div><div class=preuve><div class=entete>Prouver l'algorithme itératif</div><div class=demo><ol><li>Terminaison : on utilise une boucle non bornée avec y qui est le convergent. On affecte à y le reste de la division par y (c'est donc inferieur à y). y décroit ainsi jusqu'à 0, ce qui est la condition de fin de la boucle.</li><li>Correction : Tout diviseur commun de a et b divise aussi r = a - bq, et réciproquement tout diviseur commun de b et r divise aussi a = bq + r. Donc le calcul du PGCD de a et b se ramène à celui du PGCD de b et r.<br>l'invariant de boucle, c'est donc :<br>euclide(a,b) = euclide(b, a modulo b)<br>C'est ce qui est réalisé par la fonction, puisque l'on a comme valeurs pour les couples (x,y) successivement :<br>(a,b)<br>(b, a mod b)<br>(a mod b, (a mod b) mod (a mod b))...<br>(* , 0)<br></li></ol></div></div><h2 id=algorithme-recursif>algorithme recursif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>PGCD</span><span style=color:#111>(</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>):</span>
  <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>  PGCD : entier correspondant au plus grand diviseur commun de a par b
</span><span style=color:#d88200>  a et b : entiers tels que a &gt; b
</span><span style=color:#d88200>  &#34;&#34;&#34;</span>
  <span style=color:#00a8c8>if</span> <span style=color:#111>b</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>a</span>
  <span style=color:#00a8c8>else</span><span style=color:#111>:</span>
    <span style=color:#111>c</span> <span style=color:#f92672>=</span> <span style=color:#111>a</span> <span style=color:#f92672>%</span> <span style=color:#111>b</span><span style=color:#111>;</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>PGCD</span><span style=color:#111>(</span><span style=color:#111>b</span><span style=color:#111>,</span><span style=color:#111>c</span><span style=color:#111>)</span></code></pre></div><div class=preuve><div class=entete>Complexité</div><div class=demo>On prouve par récurrence que le cas le pire (c'est à dire celui où le nombre d'itérations à exécuter est le plus grand), est celui où a et b sont des termes consécutifs de la <strong>suite de Fibonacci</strong>. Cela revient à montrer que deux termes successifs de la suite de Fibonacci sont premiers entre eux.
(si leur plus grand diviseur commun est 1)<ul><li>La propriété est vraie pour n = 1 : f<sub>2</sub> et f<sub>1</sub> sont premiers entre eux.</li><li>Supposons que f<sub>n</sub> et f<sub>n-1</sub> soient premiers entre eux :<br>Soit d le PGCD de fn et fn+1, alors d divise f<sub>n+1</sub>– f<sub>n</sub>.<br>d est à la fois diviseur de f<sub>n+1</sub> et f<sub>n</sub><br>Or : (suite de Fibonacci)<br>$$f_{n+1} = f_n + f_{n-1}$$
Donc :
$$f_{n-1} = f_{n+1} - f_n$$
Il faut alors que f<sub>n-1</sub>, f<sub>n+1</sub> et f<sub>n</sub> aient un même diviseur, d. Or le diviseur commun de f<sub>n-1</sub> et f<sub>n</sub> est 1, donc d = 1.</li></ul>Dans ce <strong>pire</strong> cas, la complexité de l'algorithme est alors O(log<sub>10</sub> b). C'est proportionnel au nombre de divisions euclidiennes réalisées.</div></div><p>Les nombres de Fibonacci apparaissent aussi dans la croissance des plantes. Le nombre de pétales des différentes fleurs est souvent un nombre de la suite de Fibonacci. On remarque que l’ angle entre deux primordia successifs, tend vers L’ANGLE D’OR, et que plus les nombres successifs sont grands, plus le rapport s’approche du NOMBRE D’OR.</p><h1 id=application-suite-de-fibonacci>Application : suite de Fibonacci</h1><h2 id=définitions>Définitions</h2><p>Fibonacci était le surnom de Léonard de Pise ( 1170 -1250) . Il a posé un problème dans lequel il cherche à calculer le nombre de couples de lapins au bout de n années, lorsqu’ils se reproduisent selon les règles suivantes :</p><ul><li>Lors de la première année, l&rsquo;éleveur démarre avec un couple de lapins nouveaux nés.</li><li>Un couple de lapins donne naissance à un nouveau couple tous les ans, à partir de la 2ème année (la 1ère année, il est trop jeune).</li></ul><p>On peut compléter le tableau suivant présentant l&rsquo;effectif de ces couples de lapins :</p><table><thead><tr><th>numero de l&rsquo;année</th><th>nombre de couples de l&rsquo;année précédente</th><th>nouveau nombre de couples</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>1</td><td>1 + 0</td></tr><tr><td>3</td><td>1</td><td>1 + 1</td></tr><tr><td>4</td><td>2</td><td>2 + 1</td></tr><tr><td>5</td><td>3</td><td>3 + 2</td></tr><tr><td>6</td><td>&hellip;</td><td>&hellip;</td></tr></tbody></table><p>On définit la suite (f<sub>n</sub>) des nombres de Fibonacci par :
$$\left\{\begin{matrix}\begin{align}f_0 &amp; =0\\f_1 &amp; =1\\f_{n+1} &amp; =f_{n}+f_{n-1}, \forall n \in \mathbb{N}^+\end{align}\end{matrix}\right.$$</p><h2 id=algorithme-itératif>Algorithme itératif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fibonacci</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>)</span> <span style=color:#111>:</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    fonction qui prend en paramètre n, entier sup ou egal à O.
</span><span style=color:#d88200>    cette fonction utilise une variable f de type tableau.
</span><span style=color:#d88200>    A la fin, cette fonction retourne f[n], le terme de rang n du 
</span><span style=color:#d88200>    tableau f qui contient les éléments entiers calculés selon l&#39;algorithme 
</span><span style=color:#d88200>    de fibonacci où l&#39;élement de rang i est la somme des elements i-1 et i-2.
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>f</span> <span style=color:#f92672>=</span> <span style=color:#111>[]</span>
    <span style=color:#111>f</span><span style=color:#f92672>.</span><span style=color:#111>append</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>)</span>
    <span style=color:#111>f</span><span style=color:#f92672>.</span><span style=color:#111>append</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>n</span><span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span><span style=color:#111>:</span><span style=color:#00a8c8>return</span> <span style=color:#111>f</span><span style=color:#111>[</span><span style=color:#111>n</span><span style=color:#111>]</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span> <span style=color:#111>(</span><span style=color:#ae81ff>2</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#111>):</span> 
        <span style=color:#111>f</span><span style=color:#f92672>.</span><span style=color:#111>append</span><span style=color:#111>(</span><span style=color:#111>f</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>]</span> <span style=color:#f92672>+</span> <span style=color:#111>f</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#111>])</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>f</span><span style=color:#111>[</span><span style=color:#111>n</span><span style=color:#111>]</span></code></pre></div><p><em>Exercice :</em> Ecrire un programme qui permet d&rsquo;afficher tous les nombres de la suite de Fibonacci, du rang 0 au rang n=10.</p><h2 id=algorithme-récursif>Algorithme récursif</h2><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>fibo</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    algo recursif
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span><span style=color:#111>)</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>0</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>==</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>fibonacci</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>)</span> <span style=color:#f92672>+</span> <span style=color:#111>fibonacci</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>2</span><span style=color:#111>);</span></code></pre></div><h1 id=application-les-tours-de-hanoï>Application : les tours de Hanoï</h1><h2 id=principe-1>Principe</h2><p>On considère trois tiges plantées dans une base. Au départ, sur la première tige sont enfilées N disques de plus en plus étroits. Le but du jeu est de transférer les N disques sur la troisième tige en conservant la configuration initiale.</p><p><strong>On ne peut déplacer qu&rsquo;un seul disque à la fois et il est interdit de poser un disque sur un autre plus petit.</strong></p><p>il faut à un moment ou à un autre faire la place pour pouvoir déplacer le gros disque du dessous, ce qui impose d’avoir déplacé préalablement les N–1 plus petits sur un seul et même piquet, c’est-à-dire, d’avoir résolu préalablement le problème des tours de Hanoï pour ces N–1 disques :</p><p>Le problème initial (déplacer N disques de A à C en utilisant B) devient donc &ldquo;déplacer N-1 disques de A à B, déplacer le Nème disque de A à C, puis déplacer les N-1 disques de B à C&rdquo;. Dans les deux déplacements de N-1 disques, on dispose d&rsquo;un troisième pilier dont on peut se servir&hellip;</p><p><a href=http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/><figure><img src=../images/page2/hanoi.png alt="algorithme des tours de Hanoï" width=80%><figcaption>image issue du site :<br><a href=http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/>http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/</a></figcaption></figure></a></p><h2 id=algorithme-récursif-1>algorithme récursif</h2><p>L&rsquo;algorithme récursif pour ce problème est étonnament réduit :</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>hanoi</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#f92672>=</span><span style=color:#ae81ff>2</span><span style=color:#111>,</span><span style=color:#111>c</span><span style=color:#f92672>=</span><span style=color:#ae81ff>3</span><span style=color:#111>):</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#111>n</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span><span style=color:#111>):</span>
        <span style=color:#111>hanoi</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>c</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>)</span> <span style=color:#75715e># on deplace les n-1 disques de A vers B en utilisant C</span>
        <span style=color:#00a8c8>print</span> <span style=color:#111>(</span><span style=color:#d88200>&#34;Déplace &#34;</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#d88200>&#34;sur&#34;</span><span style=color:#111>,</span><span style=color:#111>c</span><span style=color:#111>)</span>
        <span style=color:#111>hanoi</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>b</span><span style=color:#111>,</span><span style=color:#111>a</span><span style=color:#111>,</span><span style=color:#111>c</span><span style=color:#111>)</span></code></pre></div><h1 id=d-autres-domaines-exploitant-la-récursivité>D&rsquo;autres domaines exploitant la récursivité</h1><p>La récursivité se retrouvent dans d&rsquo;autres situations, où elle prend parfois d&rsquo;autres noms.</p><p>L&rsquo;<strong>autosimilarité</strong> est le caractère d&rsquo;un objet dans laquelle on peut trouver des similarités en l&rsquo;observant à différentes échelles.
<em>Exemple :</em> le Tapis de Sierpiński.</p><figure><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/6/67/Sierpinski_carpet_6%2C_white_on_black.svg/440px-Sierpinski_carpet_6%2C_white_on_black.svg.png width=300px alt="le Tapis de Sierpiński"><figcaption>le Tapis de Sierpiński et l'autosimilarité</figcaption></figure><p>Les <strong>fractales</strong> ont cette propriété d&rsquo;autosimilarité, mais elles ont plutôt à voir avec un phénomène un peu différent qui s&rsquo;appel la corécurisivité (ou corécursion). Le tapis de Sierpiński, du nom de Wacław Sierpiński, est une fractale obtenue à partir d&rsquo;un carré. Le tapis se fabrique en découpant le carré en neuf carrés égaux avec une grille de trois par trois, et en supprimant la pièce centrale, et en appliquant cette procédure récursivement aux huit carrés restants.</p><p>La <strong>mise en abyme</strong> est un procédé consistant à représenter une œuvre dans une œuvre similaire, par exemple en incrustant dans une image cette image elle-même.</p><p><em>Approfondir :</em> voir la page <a href=https://fr.wikipedia.org/wiki/Algorithme_récursif>https://fr.wikipedia.org/wiki/Algorithme_récursif</a></p><h1 id=exercices>Exercices</h1><h2 id=ex-1>Ex 1 :</h2><p>Pour les algorithmes itératifs proposés :</p><ul><li>réaliser la preuve de l&rsquo;algorithme.</li><li>écrire l&rsquo;algorithme récursif</li><li>prouver l&rsquo;algorithme récursif</li></ul><h3 id=algorithme-1-longueur-d-une-liste>algorithme 1 : longueur d&rsquo;une liste</h3><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>len_iterative</span><span style=color:#111>(</span><span style=color:#111>seq</span><span style=color:#111>):</span> 
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    Return the length of a list (iterative) 
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>count</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>elt</span> <span style=color:#f92672>in</span> <span style=color:#111>seq</span><span style=color:#111>:</span>
        <span style=color:#111>count</span> <span style=color:#f92672>=</span> <span style=color:#111>count</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> 
    <span style=color:#00a8c8>return</span> <span style=color:#111>count</span></code></pre></div><p><em>Aide pour l&rsquo;écriture de l&rsquo;algorithme recursif :</em> la fonction récursive s&rsquo;appelera <code>len_recursive</code>, et aura aussi pour argument <code>seq</code>. Si on veut passer en argument la liste <code>seq</code> de laquelle on retire le premier élément, on fait : <code>len_recursive(seq[1:])</code>. Il faudra alors s&rsquo;inspirer de la relation de récurence suivante : $$u_{n+1} = 1 + u_n$$</p><h3 id=algorithme-2-retournement-d-une-liste>algorithme 2 : retournement d&rsquo;une liste</h3><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>reverse_iterative</span><span style=color:#111>(</span><span style=color:#111>seq</span><span style=color:#111>):</span> 
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    Return the reverse of a string 
</span><span style=color:#d88200>    use insert(index, elem) -- inserts the element at the given index, shifting elements to the right.
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#111>reversed_seq</span> <span style=color:#f92672>=</span> <span style=color:#111>[]</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#111>len</span><span style=color:#111>(</span><span style=color:#111>seq</span><span style=color:#111>)):</span>
        <span style=color:#111>reversed_seq</span><span style=color:#f92672>.</span><span style=color:#111>insert</span><span style=color:#111>(</span><span style=color:#ae81ff>0</span><span style=color:#111>,</span> <span style=color:#111>seq</span><span style=color:#111>[</span><span style=color:#111>i</span><span style=color:#111>])</span>
    <span style=color:#00a8c8>return</span> <span style=color:#111>reversed_seq</span></code></pre></div><p>On peut tester cette fonction dans une cellule d&rsquo;un jupyter notebook :</p><table><tr><th scope=row>IN</th><td>seq = 'abcd'<br>reverse_iterative(seq)</td></tr><tr><th scope=row>OUT</th><td>['d', 'c', 'b', 'a']</td></tr></table><p><em>Aide pour l&rsquo;écriture de l&rsquo;algorithme récursif :</em>
La première étape est de définir notre scénario de base, qui vérifiera si la chaîne est égale à 0 et, si oui, retourne la chaîne elle-même.</p><p>La deuxième étape est d&rsquo;appeler de manière récursif la fonction d&rsquo;inversion afin d&rsquo;extraire le premier caractère et ensuite l&rsquo;ajouter à la fin de la chaîne (par concaténation).
On pourra s&rsquo;inspirer de la relation de recurence suivante :
$$seq_{n+1} = seq_n[1:] + seq_n[0]$$</p><h2 id=ex-2-exponentiation>Ex 2 : Exponentiation</h2><p>Etudions l&rsquo;exponentiation à travers deux exemples.</p><div class=highlight><pre style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#00a8c8>def</span> <span style=color:#75af00>exp1</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>)</span> <span style=color:#111>:</span> 
  <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>  programme qui donne x^n en sortie sans utiliser **
</span><span style=color:#d88200>  n : entier
</span><span style=color:#d88200>  x : reel
</span><span style=color:#d88200>  exp1 : reel
</span><span style=color:#d88200>  &#34;&#34;&#34;</span>
  <span style=color:#111>acc</span><span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>i</span> <span style=color:#f92672>in</span> <span style=color:#111>range</span><span style=color:#111>(</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>n</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#111>):</span>
    <span style=color:#111>acc</span><span style=color:#f92672>*=</span><span style=color:#111>x</span>
  <span style=color:#00a8c8>return</span> <span style=color:#111>acc</span>

<span style=color:#00a8c8>def</span> <span style=color:#75af00>exp2</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>):</span>
    <span style=color:#d88200>&#34;&#34;&#34;
</span><span style=color:#d88200>    n : entier
</span><span style=color:#d88200>    x : reel
</span><span style=color:#d88200>    exp1 : reel
</span><span style=color:#d88200>    &#34;&#34;&#34;</span>
    <span style=color:#00a8c8>if</span> <span style=color:#111>n</span><span style=color:#f92672>==</span><span style=color:#ae81ff>0</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#ae81ff>1</span>
    <span style=color:#00a8c8>else</span> <span style=color:#111>:</span> <span style=color:#00a8c8>return</span> <span style=color:#111>exp2</span><span style=color:#111>(</span><span style=color:#111>n</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#111>,</span><span style=color:#111>x</span><span style=color:#111>)</span><span style=color:#f92672>*</span><span style=color:#111>x</span></code></pre></div><ol><li>Combien de produits sont necessaires pour calculer une puissance n-ième avec la fonction <code>exp1</code> ?</li><li>Pour la fonction <code>exp2</code> : Soit u<sub>n</sub> le nombre de produits nécessaires pour calculer une puissance n-ième. Quelle est la relation de récurrence vérifiée par u<sub>n+1</sub> ? $$u_{n+1} = u_n + &hellip;$$</li><li>En déduire la complexité pour ces 2 fonctions.</li></ol><h1 id=liens>Liens</h1><ul><li>article sur les tours de Hanoi <a href=http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/>http://accromath.uqam.ca/2016/02/les-tours-de-hanoi-et-la-base-trois/</a></li><li>algorithmes recursifs : <a href=https://fr.wikipedia.org/wiki/Algorithme_récursif>https://fr.wikipedia.org/wiki/Algorithme_récursif</a></li></ul></article><div style=height:100px></div></div><aside class="book-toc fixed"><nav id=TableOfContents><ul><li><a href=#récursivité>Récursivité</a><ul><li><a href=#principe>Principe</a></li><li><a href=#complexité-d-un-algorithme-recursif>Complexité d&rsquo;un algorithme recursif</a></li><li><a href=#exemple-factorielle>exemple : factorielle</a><ul><li><a href=#programme-itératif>programme itératif</a></li><li><a href=#programme-recursif>Programme recursif</a></li><li><a href=#complexité>Complexité</a></li></ul></li></ul></li><li><a href=#preuve-de-correction-d-un-algorithme-récursif>Preuve de correction d&rsquo;un algorithme récursif</a></li><li><a href=#application-recherche-du-pgcd>Application : recherche du PGCD</a><ul><li><a href=#problème>Problème</a></li><li><a href=#algorithme-d-euclide>algorithme d&rsquo;Euclide</a></li><li><a href=#algorithme-pgcd-itératif>Algorithme PGCD itératif</a></li><li><a href=#algorithme-recursif>algorithme recursif</a></li></ul></li><li><a href=#application-suite-de-fibonacci>Application : suite de Fibonacci</a><ul><li><a href=#définitions>Définitions</a></li><li><a href=#algorithme-itératif>Algorithme itératif</a></li><li><a href=#algorithme-récursif>Algorithme récursif</a></li></ul></li><li><a href=#application-les-tours-de-hanoï>Application : les tours de Hanoï</a><ul><li><a href=#principe-1>Principe</a></li><li><a href=#algorithme-récursif-1>algorithme récursif</a></li></ul></li><li><a href=#d-autres-domaines-exploitant-la-récursivité>D&rsquo;autres domaines exploitant la récursivité</a></li><li><a href=#exercices>Exercices</a><ul><li><a href=#ex-1>Ex 1 :</a><ul><li><a href=#algorithme-1-longueur-d-une-liste>algorithme 1 : longueur d&rsquo;une liste</a></li><li><a href=#algorithme-2-retournement-d-une-liste>algorithme 2 : retournement d&rsquo;une liste</a></li></ul></li><li><a href=#ex-2-exponentiation>Ex 2 : Exponentiation</a></li></ul></li><li><a href=#liens>Liens</a></li></ul></nav></aside></main><div class=site_footer><a rel=license href=http://creativecommons.org/licenses/by/4.0/><img alt="Licence Creative Commons" style=border-width:0 src=/creative.png></a>
<span xmlns:dct=http://purl.org/dc/terms/ property=dct:title>Sciences numeriques</span> de <a xmlns:cc=http://creativecommons.org/ns# href property=cc:attributionName rel=cc:attributionurl>numerix.netlify.com</a> est mis à disposition selon les termes de la <a rel=license href=http://creativecommons.org/licenses/by/4.0/>licence Creative Commons Attribution 4.0 International</a></div></body></html>